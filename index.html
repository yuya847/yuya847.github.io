<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>テキストQRコード変換</title>

<!-- Favicon / iOS -->
<link rel="icon" href="/favicon.svg" type="image/svg+xml">
<link rel="apple-touch-icon" href="/apple-touch-icon-180.png" sizes="180x180">
<meta name="theme-color" content="#0d47a1">

<!-- Material Symbols -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,400,0,0" rel="stylesheet">

<style>
:root{
  --fg:#222; --bg:#fff; --muted:#666; --br:#e0e0e0;
  --pri:#0d47a1; --sec:#039be5; --tone:#81d4fa; --err:#d32f2f; --surf:#eceff1;
}
html,body{height:100%}
body{
  margin:0; font-family:Meiryo,"Yu Gothic",sans-serif;
  color:var(--fg); background:var(--bg);
  display:flex; flex-direction:column;
}

/* Material Symbols */
.material-symbols-outlined{
  font-family:'Material Symbols Outlined';
  font-variation-settings:'FILL' 0,'wght' 400,'GRAD' 0,'opsz' 24;
  font-weight:normal; font-style:normal; line-height:1; display:inline-block;
  -webkit-font-smoothing:antialiased; font-size:22px;
}

/* Header */
header{background:#2d2d2d;color:#fff;padding:10px 14px}
header .header-row{display:flex;align-items:center;justify-content:space-between;gap:12px}
header h1{margin:0;font-size:16px;display:flex;align-items:center;gap:8px}
header h1 img{width:20px;height:20px;display:block}
.badge{display:inline-block;background:#444;color:#fff;padding:4px 8px;border-radius:999px;font-size:12px;border:1px solid #666}

/* Container */
.container{padding:12px;display:flex;flex-direction:column;gap:12px}

/* === Segmented tabs === */
.mode{display:flex;flex-wrap:wrap}
.seg{
  display:flex; flex-wrap:wrap; gap:8px;
  border:1px solid var(--br); border-radius:999px; padding:8px;
  background:#fff; width:100%;
}
.seg button{
  display:inline-flex; align-items:center; gap:8px;
  padding:8px 12px; border:1px solid var(--br); border-radius:999px;
  background:#fff; color:#222; cursor:pointer; white-space:nowrap;
  transition:background-color .15s, transform .06s, box-shadow .15s, filter .15s;
  min-width:0;
}
.seg button.sel{ background:#e3e6ed; font-weight:700; }
.seg button:hover:not(:disabled){ transform:translateY(-1px); box-shadow:0 2px 8px rgb(0 0 0 / .12); }

.seg .lbl{ font-size:14px }
.seg .i{ display:inline-flex; align-items:center; }
.seg .arrow{ font-size:16px; opacity:.75; margin:0 -2px }
.seg .b64-mark{ font-weight:700; letter-spacing:.3px; font-size:12px; }

/* QR複数：同サイズ2枚重ね（小さめ） */
.qr2{ position:relative; width:20px; height:20px; }
.qr2 .material-symbols-outlined{ font-size:14px !important; position:absolute; }
.qr2 .a{ left:-1px; top:-1px; }
.qr2 .b{ left:7px; top:7px; }

/* PC（広い時）＝日本語ラベルのみ表示 */
@media(min-width:901px){
  .seg .i, .seg .arrow, .seg .b64-mark{ display:none !important; }
  .seg .lbl{ display:inline !important; }
}

/* スマホ：4列・アイコン＋矢印のみ表示 */
@media(max-width:640px){
  .seg{
    display:grid;
    grid-template-columns:repeat(4, minmax(0,1fr));
    gap:6px; padding:6px; border-radius:12px;
  }
  .seg button{ padding:8px 6px; justify-content:center; min-height:44px; gap:4px }
  .seg .lbl{ display:none }
  .seg .material-symbols-outlined{ font-size:20px }
  .seg .arrow{ font-size:16px }
  .seg .b64-mark{ display:inline; font-size:11px }
}

/* Panels / Grid */
.grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
@media(max-width:900px){ .grid{ grid-template-columns:1fr } }
.panel{border:1px solid var(--br);border-radius:8px;padding:12px;background:#fff;display:flex;flex-direction:column;gap:8px}
.panel h2{margin:0;font-size:15px}
textarea{width:100%;min-height:220px;resize:vertical;font-size:16px;line-height:1.5;padding:10px;box-sizing:border-box;border:1px solid #ccc;border-radius:6px}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.row.right{justify-content:flex-end}

/* Buttons */
button,select,input[type="text"],input[type="file"],input[type="number"]{
  font-size:15px;padding:8px 12px;border:1px solid #bbb;border-radius:8px;background:#fff
}
button{cursor:pointer}
.btn-pri{ background:var(--pri); color:#fff; border:none }
.btn-sec{ background:var(--sec); color:#fff; border:none }
.btn-tonal{ background:var(--tone); color:#0d47a1; border:none }
.btn-err{ background:var(--err); color:#fff; border:none }
.btn-surf{ background:var(--surf); color:#111; border:none }
button:disabled{opacity:.6;cursor:default}

/* 丸いアイコンボタン */
.icon-btn{
  width:40px; height:40px; display:inline-flex; align-items:center; justify-content:center;
  border-radius:50%;
}

/* フォームとボタン列の距離 */
#input-actions, #row-output-actions, #b2f-row{ margin-top:8px; }

/* Dropzone */
.card{border:2px dashed #b0bec5; border-radius:10px; padding:16px; background:#fafafa; text-align:center}
.card.big{min-height:220px; display:flex; align-items:center; justify-content:center; font-size:15px}

/* 送信用QR */
.qr-wrap{display:flex;align-items:center;justify-content:center;height:320px;background:#fff;border:1px solid #eee;border-radius:8px;overflow:hidden}
.qr-controls{display:flex;flex-direction:column;gap:10px}
.qr-scrub{display:flex;align-items:center;gap:8px}
.qr-bottom{display:flex;align-items:center;gap:10px;justify-content:center;flex-wrap:wrap}
.time{min-width:60px;text-align:right;font-variant-numeric:tabular-nums}
.range{flex:1}
.fps-wrap{display:flex;align-items:center;gap:6px}
.fps-wrap input[type="number"]{ width:84px; text-align:right }

/* 再生ボタンだけ1.2倍 */
#btn-play.icon-btn{ width:48px; height:48px; }

/* カメラ受信 */
.cam-wrap{display:flex;flex-direction:column;gap:10px}
.video-box{position:relative}
video#cam{width:100%;max-height:320px;background:#000;border-radius:8px;display:block}
canvas.overlay{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
.rx-row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}

/* Help Modal */
.modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:10000}
.modal.show{display:flex}
.modal .box{width:min(900px,92vw);max-height:86vh;overflow:auto;background:#fff;border-radius:12px;padding:14px 16px;box-shadow:0 12px 30px rgba(0,0,0,.2)}
.modal .topbar{display:flex;justify-content:space-between;align-items:center;gap:8px;border-bottom:1px solid var(--br);padding-bottom:8px;margin-bottom:10px}
.modal .btn-close{background:#eee}
.modal .sec{margin:12px 0}
.modal h3{margin:6px 0 4px}
.modal ul{margin:6px 0 6px 1.2em;padding:0}
.qr-contact{display:flex;gap:12px;align-items:center}
.qr-cell{width:120px;height:120px;border:1px solid #eee;border-radius:8px;display:flex;align-items:center;justify-content:center;background:#fff}
kbd{background:#f2f3f7;border:1px solid #dcdfe6;border-bottom-width:2px;border-radius:4px;padding:0 6px;font-family:ui-monospace,Menlo,Consolas,monospace}


/* 任意: progress の indeterminate 風（簡易） */
progress:not([value]) { animation: pulse 1.2s ease-in-out infinite; }
@keyframes pulse { 0%{opacity:.45} 50%{opacity:1} 100%{opacity:.45} }

/* モバイル：縦並び */
@media(max-width:640px){ .grid{ grid-template-columns:1fr } }

/* Motion reduce */
@media (prefers-reduced-motion: reduce){ *{ transition:none !important; animation:none !important; } }

/* 軽めの説明 */
#mode-desc{ padding:8px 10px !important; }
#mode-desc .muted{ color:#616161; font-size:13px; }

/* ==== Tooltip (吹き出し) ==== */
[data-tip] { position: relative; }
[data-tip]::after{
  content: attr(data-tip);
  position: absolute;
  bottom: calc(100% + 10px);
  left: 50%;
  transform: translateX(-50%) translateY(4px) scale(.98);
  background: rgba(33,33,33,.95);
  color: #fff;
  padding: 4px 6px;
  border-radius: 6px;
  font-size: 11px;
  line-height: 1.35;
  white-space: nowrap;
  writing-mode: horizontal-tb;
  box-shadow: 0 8px 24px rgba(0,0,0,.18);
  pointer-events: none;
  opacity: 0;
  transition: opacity .12s ease-out, transform .12s ease-out;
  z-index: 9999;
}
[data-tip]::before{
  content: "";
  position: absolute;
  bottom: calc(100% + 2px);
  left: 50%;
  transform: translateX(-50%) translateY(4px);
  border: 5px solid transparent;
  border-top-color: rgba(33,33,33,.95);
  opacity: 0;
  transition: opacity .12s ease-out, transform .12s ease-out;
  z-index: 9999;
}
[data-tip]:hover::after,
[data-tip]:hover::before,
[data-tip]:focus-visible::after,
[data-tip]:focus-visible::before{
  opacity: 1;
  transform: translateX(-50%) translateY(0) scale(1);
}
@media (min-width:901px){
  .seg button[data-tip]::after,
  .seg button[data-tip]::before{ content:none !important; }
}

/* ==== Hover Motion ==== */
button, .icon-btn{
  transition: transform .08s ease-out, filter .15s ease-out, box-shadow .15s ease-out;
  will-change: transform, filter;
}
button:not(:disabled):hover,
.icon-btn:not(:disabled):hover{
  transform: translateY(-1px) scale(1.03);
  filter: brightness(1.06);
  box-shadow: 0 2px 8px rgba(0,0,0,.12);
}
button:not(:disabled):focus-visible,
.icon-btn:not(:disabled):focus-visible{
  outline: 2px solid var(--sec);
  outline-offset: 2px;
  transform: translateY(-1px) scale(1.03);
}
.seg button:hover:not(:disabled){
  transform: translateY(-1px) scale(1.03);
  filter: brightness(1.05);
  box-shadow: 0 2px 8px rgb(0 0 0 / .12);
}

/* ==== 目立たない開発トグル＆ログ ==== */
#dev-opts{ align-self:flex-end; font-size:11px; opacity:.35; display:flex; gap:12px; }
#dev-opts label{ cursor:pointer; user-select:none; }
#dev-opts input{ vertical-align:middle }
#dev-opts:hover{ opacity:.7 }

#log-panel{
  position:fixed; right:12px; bottom:12px;
  width:min(360px,92vw); max-height:44vh; overflow:auto;
  border:1px solid var(--br); border-radius:10px; padding:10px;
  background:#fff; box-shadow:0 10px 24px rgba(0,0,0,.18);
  display:none; z-index:9998;
}
#log-panel .bar{display:flex;align-items:center;justify-content:space-between;gap:6px;margin-bottom:6px}
#log-panel h3{ margin:0; font-size:13px; }
#log-close{
  width:28px; height:28px; border-radius:6px; border:1px solid var(--br);
  background:#f6f6f6; cursor:pointer; line-height:1;
}
#log-close:hover{ filter:brightness(1.05) }
#log-panel pre{
  margin:0; font-size:12px; line-height:1.35; white-space:pre-wrap;
  font-family:ui-monospace,Menlo,Consolas,monospace;
}
</style>

<!-- QR & Scanner -->
<script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js" defer></script>
<!-- pako (deflate/inflate) -->
<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js" defer></script>
<!-- ★ 追加: PDF生成（jsPDF） -->
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js" defer></script>
</head>
<body>
<header>
  <div class="header-row">
    <h1>
      <img src="/favicon.svg" alt="logo">
      テキストQRコード変換
    </h1>
    <div class="header-actions">
      <span id="ver" class="badge">ver 1.7</span>
      <button id="btn-help" class="icon-btn btn-sec" data-tip="ヘルプ (F1)">
        <span class="material-symbols-outlined">help</span>
      </button>
    </div>
  </div>
</header>

<div class="container">

  <!-- モード切替 -->
  <div class="mode">
    <div class="seg" role="tablist" aria-label="mode">
      <button id="m-enc" class="sel" role="tab" data-tip="テキスト → Base64">
        <span class="i"><span class="material-symbols-outlined">text_ad</span></span>
        <span class="arrow material-symbols-outlined">arrow_forward</span>
        <span class="i"><span class="b64-mark">B64</span></span>
        <span class="lbl">テキスト → Base64</span>
      </button>
      <button id="m-dec" role="tab" data-tip="Base64 → テキスト">
        <span class="i"><span class="b64-mark">B64</span></span>
        <span class="arrow material-symbols-outlined">arrow_forward</span>
        <span class="i"><span class="material-symbols-outlined">text_ad</span></span>
        <span class="lbl">Base64 → テキスト</span>
      </button>
      <button id="m-file" role="tab" data-tip="ファイル → Base64">
        <span class="i"><span class="material-symbols-outlined">folder</span></span>
        <span class="arrow material-symbols-outlined">arrow_forward</span>
        <span class="i"><span class="b64-mark">B64</span></span>
        <span class="lbl">ファイル → Base64</span>
      </button>
      <button id="m-b2f" role="tab" data-tip="Base64 → ファイル">
        <span class="i"><span class="b64-mark">B64</span></span>
        <span class="arrow material-symbols-outlined">arrow_forward</span>
        <span class="i"><span class="material-symbols-outlined">folder</span></span>
        <span class="lbl">Base64 → ファイル</span>
      </button>
      <button id="m-cam" role="tab" data-tip="QR → Base64">
        <span class="i"><span class="material-symbols-outlined">qr_code_scanner</span></span>
        <span class="arrow material-symbols-outlined">arrow_forward</span>
        <span class="i"><span class="b64-mark">B64</span></span>
        <span class="lbl">QR → Base64</span>
      </button>
      <button id="m-camtxt" role="tab" data-tip="QR → テキスト">
        <span class="i"><span class="material-symbols-outlined">qr_code_scanner</span></span>
        <span class="arrow material-symbols-outlined">arrow_forward</span>
        <span class="i"><span class="material-symbols-outlined">text_ad</span></span>
        <span class="lbl">QR → テキスト</span>
      </button>
      <button id="m-cam-multi" role="tab" data-tip="QR複数 → Base64">
        <span class="i qr2">
          <span class="material-symbols-outlined a">qr_code_2</span>
          <span class="material-symbols-outlined b">qr_code_2</span>
        </span>
        <span class="arrow material-symbols-outlined">arrow_forward</span>
        <span class="i"><span class="b64-mark">B64</span></span>
        <span class="lbl">QR複数 → Base64</span>
      </button>
      <button id="m-camtxt-multi" role="tab" data-tip="QR複数 → テキスト">
        <span class="i qr2">
          <span class="material-symbols-outlined a">qr_code_2</span>
          <span class="material-symbols-outlined b">qr_code_2</span>
        </span>
        <span class="arrow material-symbols-outlined">arrow_forward</span>
        <span class="i"><span class="material-symbols-outlined">text_ad</span></span>
        <span class="lbl">QR複数 → テキスト</span>
      </button>
    </div>
  </div>

  <!-- モード説明（控えめ） -->
  <div id="mode-desc" class="panel" style="padding:8px 10px;">
    <div id="desc-text" class="muted">
      文章をBase64という文字列に変換します。Base64を介してQRコードに変換可能です。電子カルテにスマートフォンでメモした文章を入力したいときなど便利です。
    </div>
  </div>

  <!-- 入出力 -->
  <div class="grid" id="text-io">
    <!-- 入力 -->
    <section class="panel" id="panel-input">
      <h2>入力</h2>

      <textarea id="input" placeholder="ここにテキストまたはBase64を入力…"></textarea>

      <div id="drop-zone" class="card big" style="display:none;">
        <div>
          <div>ファイルをドラッグ＆ドロップ</div>
          <div style="margin-top:8px"><button id="btn-file-choose" class="btn-surf">ファイル選択</button></div>
          <input id="file-input" type="file" style="display:none"/>
        </div>
      </div>

      <div id="b2f-row" class="row" style="display:none; justify-content:space-between; align-items:center;">
        <div class="row" style="gap:8px">
          <button id="btn-paste" class="icon-btn btn-tonal" data-tip="クリップボードをペースト">
            <span class="material-symbols-outlined">content_paste</span>
          </button>
          <button id="btn-clear" class="icon-btn btn-err" data-tip="クリア">
            <span class="material-symbols-outlined">delete</span>
          </button>
        </div>

        <div class="row" style="gap:8px; margin-left:auto">
          <input id="filename" type="text" placeholder="保存時のファイル名（拡張子なし）" style="min-width:160px"/>
          <select id="filetype">
            <option value="pdf">pdf</option>
            <option value="docx">docx</option>
            <option value="xlsx">xlsx</option>
            <option value="pptx">pptx</option>
            <option value="png">png</option>
            <option value="jpg">jpg</option>
            <option value="mp4">mp4</option>
            <option value="exe">exe</option>
            <option value="bin">bin</option>
          </select>
          <button id="btn-save" class="btn-pri" data-tip="名前を付けて保存">
            <span class="material-symbols-outlined">save_as</span>
          </button>
        </div>
      </div>

      <div id="input-actions" class="row" style="justify-content:space-between;">
        <div class="row">
          <button id="btn-paste-text" class="icon-btn btn-tonal" data-tip="クリップボードをペースト">
            <span class="material-symbols-outlined">content_paste</span>
          </button>
          <button id="btn-clear-text" class="icon-btn btn-err" data-tip="クリア">
            <span class="material-symbols-outlined">delete</span>
          </button>
        </div>
        <div class="row">
          <button id="btn-convert" class="icon-btn btn-tonal" data-tip="変換 (Ctrl+Enter)">
            <span class="material-symbols-outlined">convert_to_text</span>
          </button>
          <button id="btn-convert-qr" class="icon-btn btn-sec" data-tip="変換＋QR (Shift+Enter)">
            <span class="material-symbols-outlined">qr_code_2</span>
          </button>
        </div>
      </div>
    </section>

    <!-- 出力 -->
    <section class="panel" id="panel-output">
      <h2>出力</h2>
      <textarea id="output" placeholder="ここに結果が表示されます"></textarea>

      <div class="row" id="row-output-actions" style="justify-content:space-between">
        <div class="row">
          <button id="btn-copy" class="icon-btn btn-tonal" data-tip="コピー">
            <span class="material-symbols-outlined">content_copy</span>
          </button>
          <button id="btn-share" class="icon-btn btn-tonal" data-tip="共有" style="display:none;">
            <span class="material-symbols-outlined">ios_share</span>
          </button>
        </div>
        <div class="row" id="row-output-right" style="display:none;">
          <button id="btn-qrshow" class="icon-btn btn-sec" data-tip="QR表示">
            <span class="material-symbols-outlined">qr_code</span>
          </button>
        </div>
      </div>
    </section>
  </div>

  <!-- 送信用QR -->
  <section class="panel" id="qr-send">
    <h2>QRシーケンス出力</h2>
    <div class="qr-controls">
      <div class="qr-wrap" id="qr-display"></div>
      <div class="qr-scrub">
        <span id="elapsed" class="time">00:00</span>
        <input id="scrub" class="range" type="range" min="0" max="0" step="1" value="0"/>
        <span id="duration" class="time">00:00</span>
        <span id="frame-ind" class="muted">0 / 0</span>
      </div>
      <div class="qr-bottom">
        <button id="btn-prev" class="icon-btn btn-surf" data-tip="前のQR (←)">
          <span class="material-symbols-outlined">fast_rewind</span>
        </button>
        <button id="btn-play" class="icon-btn btn-tonal" data-tip="再生/一時停止 (Space)">
          <span class="material-symbols-outlined">play_arrow</span>
        </button>
        <button id="btn-next" class="icon-btn btn-surf" data-tip="次のQR (→)">
          <span class="material-symbols-outlined">fast_forward</span>
        </button>
        <div class="fps-wrap">
          <label for="fps">FPS</label>
          <input id="fps" type="range" min="0.2" max="120" step="0.1" value="2"/>
          <input id="fps-num" type="number" min="0.2" max="120" step="0.1" value="2"/>
        </div>
        <label class="nohdr" style="opacity:.7">
          <input id="with-header" type="checkbox" checked> ヘッダーをつける
        </label>
      </div>

<!-- ★ 追加: A4 PDF 出力コントロール -->
<div class="row" id="pdf-controls" style="justify-content:flex-end; gap:8px; flex-wrap:wrap; margin-top:6px">
  <label>PDF 行: <input id="pdf-rows" type="number" min="1" max="8" value="2" style="width:72px"></label>
  <label>列: <input id="pdf-cols" type="number" min="1" max="8" value="4" style="width:72px"></label>
  <label>余白(mm): <input id="pdf-margin" type="number" min="0" max="30" value="10" style="width:96px"></label>
  <button id="btn-make-pdf" class="btn-pri" data-tip="A4にQRを並べてPDF出力">
    <span class="material-symbols-outlined">picture_as_pdf</span>
  </button>
</div>

      
    </div>
  </section>

  <!-- 受信用（カメラ） -->
  <section class="panel" id="qr-recv" style="display:none;">
    <h2>QR入力</h2>
    <div class="cam-wrap">
      <div class="rx-row">
        <button id="btn-scan-start" class="icon-btn btn-pri" data-tip="カメラ開始">
          <span class="material-symbols-outlined">qr_code_scanner</span>
        </button>
        <button id="btn-scan-stop" class="icon-btn btn-err" data-tip="停止">
          <span class="material-symbols-outlined">stop</span>
        </button>
      </div>

      <div class="rx-row" id="auto-stop-wrap" style="display:none; opacity:.75; font-size:13px">
        <label class="nohdr">
          <input id="auto-stop-hl" type="checkbox"> ヘッダーなしは1枚読んだら自動停止（QR→テキスト）
        </label>
      </div>

      <div class="rx-row" id="grid-opts" style="display:none;">
        <label>行: <input id="rows" type="number" min="1" max="6" value="2"></label>
        <label>列: <input id="cols" type="number" min="1" max="6" value="2"></label>
        <label>ROI余白(px): <input id="roi-margin" type="number" min="0" max="80" value="16"></label>
        <span class="muted">電子カルテ側のマス数に合わせてください（例: 2×2）。</span>
      </div>

      <div class="video-box">
        <video id="cam" playsinline muted></video>
        <canvas id="cam-overlay" class="overlay"></canvas>
      </div>
      <canvas id="cam-canvas" style="display:none"></canvas>

      <div class="muted">受信進捗（ヘッダー付き時）: <span id="rx-status">0/0</span></div>
    </div>
  </section>

  <!-- 目立たない開発トグル（ワーカーは複数読み取り時のみ表示 / 圧縮はENCの時のみ表示） -->
  <div id="dev-opts" class="muted">
    <label><input id="toggle-logs" type="checkbox"> 簡易ログ</label>
    <label id="worker-opt" style="display:none"><input id="toggle-workers" type="checkbox"> Workerを使用してより高速化（β版）</label>
    <label id="compress-opt" style="display:none"><input id="toggle-compress" type="checkbox"> テキストを圧縮して送信（pako/deflate）</label>
  </div>
</div>

<!-- 簡易ログパネル -->
<div id="log-panel" aria-live="polite" aria-hidden="true">
  <div class="bar">
    <h3>簡易ログ</h3>
    <button id="log-close" title="閉じる">✕</button>
  </div>
  <pre id="log-pre"></pre>
</div>

<!-- Help Modal -->
<div id="help-modal" class="modal" aria-hidden="true">
  <div class="box" role="dialog" aria-modal="true" aria-labelledby="help-title">
    <div class="topbar">
      <h2 id="help-title">ヘルプ</h2>
      <div class="row">
        <a class="btn-surf" href="https://www.notion.so/y847/QR-228ef3115d7480528fe0f82920945df3" target="_blank" rel="noopener" style="text-decoration:none;padding:8px 12px;border-radius:8px;">Notion ドキュメント</a>
        <button id="btn-help-close" class="btn-surf">閉じる</button>
      </div>
    </div>

    <div class="content">
      <div class="sec">
        <h3>概要</h3>
        <ul>
          <li>テキスト/ファイルをBase64に変換し、QRコードで電子カルテへ橋渡しします。</li>
          <li>QRリーダー（例: DS9308）へ連続表示してデータを送ります。</li>
        </ul>
      </div>

      <div class="sec">
        <h3>モード</h3>
        <ul id="help-modes">
          <li><b>テキスト → Base64</b>：文章をBase64という文字列に変換します。Base64を介してQRコードに変換可能です。電子カルテにスマートフォンでメモした文章を入力したいときなど便利です。</li>
          <li><b>Base64 → テキスト</b>：Base64という文字列（電子カルテから送られてくる文字列データ）をテキストに変換します。電子カルテからスキャンしたQRコードはBase64で書かれています。そのコードを日本語に変換するときに便利です。</li>
          <li><b>ファイル → Base64</b>：あらゆるファイルをBase64という文字列に変換します。QRコードにすることで電子カルテに画像、PDF、EXCELファイルなどを電子カルテに入力できます。</li>
          <li><b>Base64 → ファイル</b>：Base64からファイルに変換します。電子カルテからファイルをBase64に変換して受け取ったものを再度ファイルに変換することが可能です。</li>
          <li><b>QR → Base64</b>：QRコードをBase64の形で受け取ります。電子カルテからファイルをBase64の形で受け取るときに使います。</li>
          <li><b>QR → テキスト</b>：QRコードから直接テキストに変換できます。電子カルテからファイルをBase64の形で受け取るときには使えません。</li>
          <li><b>QR複数 → Base64</b>：複数のQRコードをBase64として読み取ることができます。理論的には単一のQRコードより高速でデータを受け取ることができます。</li>
          <li><b>QR複数 → テキスト</b>：複数のQRコードをテキストとして読み取ることができます。理論的には単一のQRコードより高速でデータを受け取ることができます。</li>
        </ul>
      </div>

      <!-- ★ 追記: ショートカット -->
      <div class="sec">
        <h3>ショートカット</h3>
        <ul>
          <li><b>プレイヤー</b></li>
          <li>再生/一時停止：<kbd>Space</kbd></li>
          <li>次の QR：<kbd>→</kbd>（ArrowRight）</li>
          <li>前の QR：<kbd>←</kbd>（ArrowLeft）</li>
          <li>先頭へ：<kbd>Home</kbd></li>
          <li>最後へ：<kbd>End</kbd></li>
          <li><b>共通</b></li>
          <li>ヘルプ：<kbd>F1</kbd></li>
          <li>閉じる/ダイアログを閉じる：<kbd>Esc</kbd></li>
          <li>変換：<kbd>Ctrl</kbd> + <kbd>Enter</kbd></li>
        </ul>
      </div>

      <div class="sec">
        <h3>お問い合わせ</h3>
        <div class="qr-contact">
          <div id="help-qr" class="qr-cell" aria-label="連絡先QR"></div>
          <div>
            <div><strong>メール:</strong> <a href="mailto:suzuki.yuya.kitasato@gmail.com">suzuki.yuya.kitasato@gmail.com</a></div>
            <div class="muted">QRからメールアドレスを読み取れます。</div>
          </div>
        </div>
      </div>

      <div class="sec muted">© Yuya Suzuki</div>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
'use strict';

/* ====== バージョン ====== */
const APP_VERSION='ver 1.8', APP_BUILD='2025-08-11';
document.getElementById('ver').textContent = APP_VERSION;

/* ====== 要素 ====== */
const $ = id => document.getElementById(id);
const on = (n,e,f)=>n&&n.addEventListener(e,f,false);

const el = {
  // tabs
  mEnc: $('m-enc'), mDec: $('m-dec'), mFile: $('m-file'), mB2F: $('m-b2f'),
  mCamB64: $('m-cam'), mCamTxt: $('m-camtxt'), mCamB64M: $('m-cam-multi'), mCamTxtM: $('m-camtxt-multi'),
  // desc
  descText: $('desc-text'),
  // io
  textIO: $('text-io'), panelInput:$('panel-input'), panelOutput:$('panel-output'),
  input: $('input'), output:$('output'),
  drop: $('drop-zone'), fileBtn:$('btn-file-choose'), fileInput:$('file-input'),
  filename:$('filename'), filetype:$('filetype'),
  inputActions:$('input-actions'), b2fRow:$('b2f-row'),
  // buttons
  btnPasteText:$('btn-paste-text'), btnClearText:$('btn-clear-text'),
  btnConvert:$('btn-convert'), btnConvertQR:$('btn-convert-qr'),
  btnCopy:$('btn-copy'), btnShare:$('btn-share'),
  btnPaste:$('btn-paste'), btnClear:$('btn-clear'), btnSave:$('btn-save'),
  // NEW: 出力側QRボタン（右端コンテナ含む）
  btnQRShow:$('btn-qrshow'), rowOutputRight:$('row-output-right'),
  // send
  qrSend:$('qr-send'), qrWrap:$('qr-display'), scrub:$('scrub'),
  elapsed:$('elapsed'), duration:$('duration'), frameInd:$('frame-ind'),
  btnPrev:$('btn-prev'), btnNext:$('btn-next'), btnPlay:$('btn-play'),
  fps:$('fps'), fpsNum:$('fps-num'), withHdr:$('with-header'),
  // recv
  qrRecv:$('qr-recv'), cam:$('cam'), camCanvas:$('cam-canvas'), camOverlay:$('cam-overlay'),
  btnScanStart:$('btn-scan-start'), btnScanStop:$('btn-scan-stop'),
  autoStopWrap:$('auto-stop-wrap'), autoStopHL:$('auto-stop-hl'),
  gridOpts:$('grid-opts'), rows:$('rows'), cols:$('cols'), roiMargin:$('roi-margin'),
  rxStatus:$('rx-status'),
  // help
  helpModal:$('help-modal'), btnHelp:$('btn-help'), btnHelpClose:$('btn-help-close'), helpQR:$('help-qr'),
  // logs / toggles
  logToggle:$('toggle-logs'), logPanel:$('log-panel'), logPre:$('log-pre'), logClose:$('log-close'),
  workerToggle:$('toggle-workers'), workerOpt:$('worker-opt'),
  // 圧縮トグル
  compressToggle:$('toggle-compress'), compressOpt:$('compress-opt'),
  // ★ 追加: PDF出力
  pdfRows:$('pdf-rows'), pdfCols:$('pdf-cols'), pdfMargin:$('pdf-margin'), btnMakePDF:$('btn-make-pdf'),
 // ★ 追加: PDF進捗UI
  pdfProg: $('pdf-progress'),
  pdfProgLabel: $('pdf-pr-label'),
  pdfProgBar: $('pdf-pr-bar'),
  btnPDFCancel: $('btn-pdf-cancel'),
};

/* ====== 吹き出しショートカット ====== */
function applyShortcutTips(){
  if(el.btnConvert)   el.btnConvert.setAttribute('data-tip','変換 (Ctrl+Enter)');
  if(el.btnConvertQR) el.btnConvertQR.setAttribute('data-tip','変換＋QR (Shift+Enter)');
  if(el.btnPlay)      el.btnPlay.setAttribute('data-tip','再生/一時停止 (Space)');
  if(el.btnPrev)      el.btnPrev.setAttribute('data-tip','前のQR (←)');
  if(el.btnNext)      el.btnNext.setAttribute('data-tip','次のQR (→)');
  if(el.btnHelp)      el.btnHelp.setAttribute('data-tip','ヘルプ (F1)');
}
applyShortcutTips();

/* ====== Worker Pool (ImageBitmap) ====== */
let USE_WORKERS = false;
const WORKERS_IN_MULTI_ONLY = true;

let WORKERS = [];
let WORKER_URL = '';
let WORKER_ALIVE = [];
let IDLE = [];
let pendingShrink = 0;
let inFlightSlots = new Set();
let detCache = [];
const DET_HOLD_MS = 180;

const SLOT_MIN_MS = 45;
const lastDispatch = new Map();

const MIN_POOL = 1;
const MAX_POOL_HARD = 8;

function getDesiredPoolSize(){
  const r = parseInt(el.rows?.value||'2', 10) || 2;
  const c = parseInt(el.cols?.value||'2', 10) || 2;
  return (isMultiMode() ? r*c : 1);
}
function countAlive(){ let n=0; for(let i=0;i<WORKER_ALIVE.length;i++) if(WORKER_ALIVE[i]) n++; return n; }
function shrinkIdleIfNeeded(){
  while (pendingShrink > 0 && IDLE.length > 0){
    const idx = IDLE.pop();
    if (!WORKER_ALIVE[idx]) continue;
    try{ WORKERS[idx].terminate(); }catch(_){}
    WORKER_ALIVE[idx] = false;
    pendingShrink--;
  }
}
function ensurePoolSize(target){
  target = Math.max(MIN_POOL, Math.min(MAX_POOL_HARD, target|0));
  const curAlive = countAlive();
  if (curAlive < target){
    const need = target - curAlive;
    for (let k=0;k<need;k++){
      const idx = WORKERS.length;
      const w = new Worker(WORKER_URL);
      w.onmessage = (ev)=>handleWorkerMsg(idx, ev.data);
      WORKERS.push(w);
      WORKER_ALIVE[idx] = true;
      IDLE.push(idx);
    }
  }else if(curAlive > target){
    pendingShrink += (curAlive - target);
    shrinkIdleIfNeeded();
  }
}
function makeWorkerURL(){
  const src = `
'use strict';
importScripts('https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js');
let canv = new OffscreenCanvas(1,1);
let ctx = canv.getContext('2d', { willReadFrequently: true });
onmessage = async (e) => {
  const { bitmap, slot, ox, oy } = e.data;
  try{
    canv.width = bitmap.width; canv.height = bitmap.height;
    ctx.clearRect(0,0,canv.width,canv.height);
    ctx.drawImage(bitmap, 0, 0);
    const img = ctx.getImageData(0,0,canv.width,canv.height);
    const t0 = performance.now();
    const code = jsQR(img.data, img.width, img.height, { inversionAttempts: 'dontInvert' });
    const t1 = performance.now();
    const loc = code?.location ? {
      tl:{x:code.location.topLeftCorner.x,    y:code.location.topLeftCorner.y},
      tr:{x:code.location.topRightCorner.x,   y:code.location.topRightCorner.y},
      br:{x:code.location.bottomRightCorner.x,y:code.location.bottomRightCorner.y},
      bl:{x:code.location.bottomLeftCorner.x, y:code.location.bottomLeftCorner.y}
    } : null;
    postMessage({ slot, ok:!!code, data: code?.data || null, time: t1-t0, loc, ox, oy });
  }catch(err){
    postMessage({ slot, ok:false, err:String(err), ox, oy });
  }finally{
    try{ bitmap.close && bitmap.close(); }catch(_){}
  }
};`;
  const blob = new Blob([src], { type:'application/javascript' });
  return URL.createObjectURL(blob);
}
function initWorkers(){
  if(!USE_WORKERS) return;
  if(!('Worker' in window) || !('createImageBitmap' in window) || typeof OffscreenCanvas==='undefined'){
    console.log('[workers] unsupported -> fallback to main thread'); return;
  }
  if(WORKERS.length) return;
  WORKER_URL = makeWorkerURL();
  ensurePoolSize(getDesiredPoolSize());
  console.log('[workers] pool init (alive):', countAlive());
}
function teardownWorkers(){
  for(let i=0;i<WORKERS.length;i++){ try{ WORKERS[i].terminate(); }catch(_){} }
  WORKERS.length = 0; IDLE.length = 0; WORKER_ALIVE.length = 0;
  pendingShrink = 0; inFlightSlots.clear(); lastDispatch.clear();
  if(WORKER_URL){ URL.revokeObjectURL(WORKER_URL); WORKER_URL=''; }
  detCache.length = 0;
}
function handleWorkerMsg(idx, msg){
  if (WORKER_ALIVE[idx]) IDLE.push(idx);
  inFlightSlots.delete(msg.slot);
  if(msg.ok && msg.loc){
    detCache.push({
      corners:[
        {x: msg.ox + msg.loc.tl.x, y: msg.oy + msg.loc.tl.y},
        {x: msg.ox + msg.loc.tr.x, y: msg.oy + msg.loc.tr.y},
        {x: msg.ox + msg.loc.br.x, y: msg.oy + msg.loc.br.y},
        {x: msg.ox + msg.loc.bl.x, y: msg.oy + msg.loc.bl.y},
      ],
      ts: performance.now()
    });
  }
  if(msg.ok && msg.data){
    handleResult(msg.data, msg.slot);
  }
  pushSample(perf.workerTimes, Number(msg.time)||0, 50);
  shrinkIdleIfNeeded();
}
async function dispatchSlots(slots){
  if(!WORKERS.length) return;
  const now = performance.now();
  for(let i=0;i<slots.length;i++){
    if(!IDLE.length || inFlightSlots.has(i)) continue;
    const last = lastDispatch.get(i) || 0;
    if (now - last < SLOT_MIN_MS) continue;
    const s = slots[i];
    inFlightSlots.add(i);
    const idx = IDLE.pop();
    try{
      const vw = el.cam.videoWidth, vh = el.cam.videoHeight;
      const sx = Math.max(0, Math.min(s.x, vw-1));
      const sy = Math.max(0, Math.min(s.y, vh-1));
      const sw = Math.max(1, Math.min(s.w, vw - sx));
      const sh = Math.max(1, Math.min(s.h, vh - sy));
      const bmp = await createImageBitmap(el.cam, sx, sy, sw, sh);
      WORKERS[idx].postMessage({ bitmap:bmp, slot:i, ox:sx, oy:sy }, [bmp]);
      lastDispatch.set(i, now);
    }catch(_){
      inFlightSlots.delete(i);
      if (WORKER_ALIVE[idx]) IDLE.push(idx);
    }
  }
}

/* ====== 簡易ログ（計測ユーティリティ） ====== */
const perf = { rafLast:0, rafSamples:[], workerTimes:[], fallbackTimes:[] };
function pushSample(arr, v, max=60){ if(!isFinite(v)||v<=0) return; arr.push(v); if(arr.length>max) arr.shift(); }
function avg(arr){ return arr.length ? (arr.reduce((a,b)=>a+b,0)/arr.length) : 0; }
function fpsFromSamples(samples){ const a = avg(samples); return a>0 ? 1000/a : 0; }
function updateLog(){
  if(!el.logToggle?.checked) return;
  const fps = fpsFromSamples(perf.rafSamples);
  const usePool = USE_WORKERS && WORKERS.length && (!WORKERS_IN_MULTI_ONLY || isMultiMode());
  const avgWorker = avg(perf.workerTimes);
  const avgFallback = avg(perf.fallbackTimes);
  const vw = el.cam?.videoWidth||0, vh = el.cam?.videoHeight||0;
  const poolActive = countAlive();
  const inFlight = inFlightSlots.size||0;
  const idle = IDLE.length||0;
  let roiCount = 0, gridTxt = '1';
  if(isMultiMode()){
    const rows = parseInt(el.rows?.value||'2',10)||2;
    const cols = parseInt(el.cols?.value||'2',10)||2;
    roiCount = rows*cols; gridTxt = `${rows}x${cols}`;
  }else{ roiCount = 1; }

  const lines = [
    `解像度: ${vw}×${vh} | モード: ${isMultiMode()? '複数QR':'単一QR'} | プール: ${usePool? 'ON':'OFF'}`,
    `fps(推定): ${fps.toFixed(1)}`,
    usePool
      ? `worker: avg ${avgWorker.toFixed(1)} ms/ROI | poolActive ${poolActive} | inFlight ${inFlight} | idle ${idle}`
      : `fallback(jsQR): avg ${avgFallback.toFixed(1)} ms/ROI`,
    `ROI: ${roiCount} / grid ${gridTxt} | ROI余白: ${el.roiMargin?.value ?? 0}`,
    `送信ヘッダー: ${el.withHdr?.checked ? 'ON（ヘッダー付き）':'OFF（ヘッダーなし）'} | 安定判定: ${typeof STABLE_FRAMES!=='undefined'? STABLE_FRAMES:2}f | TTL: ${typeof DEDUPE_TTL!=='undefined'? DEDUPE_TTL:8000}ms`,
  ];
  el.logPre.textContent = lines.join('\n');
}

/* ====== 説明文 ====== */
const DESC = {
  ENC:'文章をBase64という文字列に変換します。Base64を介してQRコードに変換可能です。\n電子カルテにスマートフォンでメモした文章を入力したいときなど便利です.',
  DEC:'Base64という文字列（電子カルテから送られてくる文字列データ）をテキストに変換します。\n：電子カルテからスキャンしたQRコードはBase64で書かれています。そのコードを日本語に変換するときに便利です。',
  FILE:'あらゆるファイルをBase64という文字列に変換します。QRコードにすることで電子カルテに画像、PDF、EXCELファイルなどを電子カルテに入力できます。',
  B2F:'Base64からファイルに変換します。電子カルテからファイルをBase64に変換して受け取ったものを再度ファイルに変換することが可能です。',
  CAM_B64:'QRコードをBase64の形で受け取ります。電子カルテからファイルをBase64の形で受け取るときに使います。',
  CAM_TXT:'QRコードから直接テキストに変換できます。電子カルテからファイルをBase64の形で受け取るときには使えません。',
  CAM_B64_MULTI:'複数のQRコードをBase64として読み取ることができます。理論的には単一のQRコードより高速でデータを受け取ることができます。',
  CAM_TXT_MULTI:'複数のQRコードをテキストとして読み取ることができます。理論的には単一のQRコードより高速でデータを受け取ることができます.'
};

/* ====== 状態 ====== */
let mode='ENC';
const tabState={
  ENC:{in:'',out:''}, DEC:{in:'',out:''}, FILE:{in:'',out:''}, B2F:{in:'',out:''},
  CAM_B64:{in:'',out:''}, CAM_TXT:{in:'',out:''}, CAM_B64_MULTI:{in:'',out:''}, CAM_TXT_MULTI:{in:'',out:''}
};
const isCamMode = ()=> /^CAM_/.test(mode);
const isTextCamMode = ()=> mode==='CAM_TXT' || mode==='CAM_TXT_MULTI';
const isMultiMode = ()=> mode==='CAM_B64_MULTI' || mode==='CAM_TXT_MULTI';

/* ====== Base64 utils ====== */
function utf8ToB64(str){
  if (window.TextEncoder){
    const bytes = new TextEncoder().encode(str);
    let bin=''; for (const b of bytes) bin+=String.fromCharCode(b);
    return btoa(bin);
  }
  return btoa(unescape(encodeURIComponent(str)));
}
function normalizeB64(b64){
  let s=(b64||'').trim();
  s=s.replace(/^data:.*;base64,/i,'').replace(/\s+/g,'').replace(/-/g,'+').replace(/_/g,'/');
  s+='='.repeat((4-(s.length%4))%4);
  return s;
}
function b64ToUtf8(b64){
  const clean=normalizeB64(b64);
  if (window.TextDecoder){
    const bin=atob(clean); const bytes=new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
    return new TextDecoder('utf-8').decode(bytes);
  }
  return decodeURIComponent(escape(atob(clean)));
}

/* ==== Pako圧縮ヘルパー ==== */
function u8ToB64(u8){
  let bin=''; for(const b of u8) bin+=String.fromCharCode(b);
  return btoa(bin);
}
function b64ToU8(b64){
  const clean = normalizeB64(b64);
  const bin = atob(clean); const u8 = new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
  return u8;
}
function maybeCompressTextToB64(str, enabled=true){
  const enc = new TextEncoder().encode(str);
  if (enabled && typeof pako!=='undefined'){
    try{
      const gz = pako.deflate(enc);
      if (gz.length < enc.length * 0.98){
        return 'gz:' + u8ToB64(gz);
      }
    }catch(_){}
  }
  return u8ToB64(enc);
}
function decodeMaybeGzipToText(s){
  const str = String(s||'');
  if (str.startsWith('gz:')){
    if (typeof pako==='undefined') throw new Error('pakoが見つかりません');
    const u8 = b64ToU8(str.slice(3));
    const plain = pako.inflate(u8);
    return new TextDecoder('utf-8').decode(plain);
  }
  return b64ToUtf8(str);
}

/* ====== QR送出 ====== */
const fmt=t=>{const s=Math.max(0,Math.floor(t));const m=String(Math.floor(s/60)).padStart(2,'0');const ss=String(s%60).padStart(2,'0');return `${m}:${ss}`;};
const checksum=str=>{let s=0;for(let i=0;i<str.length;i++) s=(s+str.charCodeAt(i))&0xffff;return s;};
const FRAME_RE=/^\[(\d+)\/(\d+)\|(\d+)\]([\s\S]*)$/;

let qrChunks=[], idx=0, playing=false, timer=null, fpsRate=2.0;
function splitFrames(text,maxPayload){
  const total=Math.ceil(text.length/maxPayload)||1, frames=[];
  for(let i=0;i<total;i++){ const p=text.slice(i*maxPayload,(i+1)*maxPayload); frames.push(`[${i+1}/${total}|${checksum(p)}]${p}`); }
  return frames;
}
function splitFramesNoHeader(text,maxPayload){
  const total=Math.ceil(text.length/maxPayload)||1, frames=[];
  for(let i=0;i<total;i++) frames.push(text.slice(i*maxPayload,(i+1)*maxPayload));
  return frames;
}
function renderQR(){
  el.qrWrap.innerHTML='';
  const text=qrChunks[idx]||'';
  new QRCode(el.qrWrap,{text,width:300,height:300,correctLevel:QRCode.CorrectLevel.M});
}
function updateTime(){
  const total=qrChunks.length;
  const dur = total / fpsRate;
  const cur = (idx+1) / fpsRate;
  const remain = Math.max(0, dur - cur);
  el.duration.textContent = fmt(remain);
  el.elapsed.textContent  = fmt(cur);
  el.frameInd.textContent=`${Math.min(idx+1,total)} / ${total}`;
}
function tickPlay(){
  if(!playing) return;
  const interval=Math.max(1,Math.round(1000/fpsRate));
  timer=setTimeout(()=>{
    if(idx<qrChunks.length-1){ idx++; el.scrub.value=idx; renderQR(); updateTime(); tickPlay(); }
    else { playing=false; el.btnPlay.querySelector('.material-symbols-outlined').textContent='play_arrow'; }
  }, interval);
}
function buildSequence(){
  const s=el.output?.value.trim();
  if(!s){ alert('出力が空です'); return false; }
  const maxPayload=700;
  const withHeader = !!(el.withHdr && el.withHdr.checked);
  qrChunks = withHeader ? splitFrames(s,maxPayload) : splitFramesNoHeader(s,maxPayload);
  idx=0; el.scrub.max=Math.max(qrChunks.length-1,0); el.scrub.value=0;
  renderQR(); updateTime();
  return true;
}

/* ====== 受信（カメラ） ====== */
const rx={ total:0, got:new Map() };
const rxTxt={ buffer:'' };
function appendHeaderedAndMaybeComplete(frame){
  const m=FRAME_RE.exec(String(frame).trim()); if(!m) return {matched:false};
  const i=parseInt(m[1],10), total=parseInt(m[2],10), sum=parseInt(m[3],10), payload=m[4];
  if (checksum(payload)!==sum){ toast('チェックサム不一致',true); return {matched:true,ok:false}; }
  if (!rx.total) rx.total=total; if(rx.total!==total){ toast('総フレーム数が一致しません',true); return {matched:true,ok:false}; }
  const dup = rx.got.has(i) && rx.got.get(i)===payload;
  rx.got.set(i,payload); el.rxStatus.textContent=`${rx.got.size}/${rx.total}`;
  if(dup) return {matched:true,ok:true,complete:false};
  if(rx.got.size===rx.total){
    const parts=[]; for(let k=1;k<=rx.total;k++){ const p=rx.got.get(k); if(typeof p!=='string'){ toast(`欠落:${k}`,true); return {matched:true,ok:false}; } parts.push(p); }
    const joined=parts.join(''); rx.total=0; rx.got.clear(); el.rxStatus.textContent='0/0';
    return {matched:true,ok:true,complete:true,payload:joined};
  }
  return {matched:true,ok:true,complete:false};
}
function ingestB64(text){
  const r=appendHeaderedAndMaybeComplete(text);
  if(!r.matched){ el.output.value+=text; }
  else if(r.complete){ el.output.value=r.payload; }
}
function ingestText(text){
  const r=appendHeaderedAndMaybeComplete(text);
  if(!r.matched){
    rxTxt.buffer+=text;
    try{ el.output.value=decodeMaybeGzipToText(rxTxt.buffer); }catch(_){}
  }else if(r.complete){
    try{ el.output.value=decodeMaybeGzipToText(r.payload); }catch(e){ toast('テキストに復号できませんでした',true); }
  }
}

/* ====== カメラ ====== */
let camStream=null, rafId=null;
const STABLE_FRAMES=2, DEDUPE_TTL=8000;
const seen = new Map();
const camD = { curr:'', same:0 };
const slotState=new Map();
function fp32(s){ let h=0x811c9dc5|0; for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h += (h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24); } return h>>>0; }

async function startScan(){
  if(typeof jsQR==='undefined'){ alert('jsQRが読み込まれていません'); return; }
  if(!navigator.mediaDevices?.getUserMedia){ alert('このブラウザはカメラに未対応です'); return; }
  try{
    if (USE_WORKERS && isMultiMode()) initWorkers();

    camStream = await navigator.mediaDevices.getUserMedia({
      video:{ facingMode:'environment', width:{ideal:1920}, height:{ideal:1080} }, audio:false
    });
    el.cam.srcObject=camStream; await el.cam.play();
    ensureOverlaySize(); drawOverlayGrid();

    if (USE_WORKERS && isMultiMode() && WORKER_URL) ensurePoolSize(getDesiredPoolSize());

    tickCam();
  }catch(e){ alert('カメラ起動に失敗: '+e.message); }
}
function stopScan(){
  if(camStream){ camStream.getTracks().forEach(t=>t.stop()); camStream=null; }
  if(rafId){ cancelAnimationFrame(rafId); rafId=null; }
  try{
    const ctx = el.camOverlay?.getContext?.('2d');
    if(ctx){
      ctx.clearRect(0,0,el.camOverlay.width||0,el.camOverlay.height||0);
    }
  }catch(_){}
  detCache.length = 0;
  inFlightSlots.clear();
  teardownWorkers();
}
function ensureOverlaySize(){
  const vw=el.cam.videoWidth||1280, vh=el.cam.videoHeight||720;
  el.camOverlay.width=vw; el.camOverlay.height=vh;
  el.camOverlay.style.width = el.cam.clientWidth+'px';
  el.camOverlay.style.height= el.cam.clientHeight+'px';
}
function drawOverlayGrid(){
  const ctx=el.camOverlay.getContext('2d');
  ctx.clearRect(0,0,el.camOverlay.width,el.camOverlay.height);
  if(!isMultiMode()) return;
  const rows=Math.max(1,Math.min(6,parseInt(el.rows.value,10)||2));
  const cols=Math.max(1,Math.min(6,parseInt(el.cols.value,10)||2));
  const w=el.camOverlay.width,h=el.camOverlay.height;
  ctx.strokeStyle='rgba(37,99,235,.9)'; ctx.lineWidth=2;
  for(let r=1;r<rows;r++){ const y=Math.round(h*r/rows)+.5; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
  for(let c=1;c<cols;c++){ const x=Math.round(w*c/cols)+.5; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
}
function drawDetections(dets){
  const ctx=el.camOverlay.getContext('2d');
  drawOverlayGrid();
  for(const d of dets){
    const pts=d.corners;
    ctx.save(); ctx.lineWidth=4; ctx.strokeStyle='rgba(16,185,129,.95)'; ctx.shadowColor='rgba(0,0,0,.45)'; ctx.shadowBlur=4;
    ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y); for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x,pts[i].y);
    ctx.closePath(); ctx.stroke();
    ctx.fillStyle='rgba(16,185,129,.95)'; for(const p of pts){ ctx.beginPath(); ctx.arc(p.x,p.y,3,0,Math.PI*2); ctx.fill(); }
    ctx.restore();
  }
}
function getSlots(){
  const vw=el.cam.videoWidth, vh=el.cam.videoHeight;
  if(!vw||!vh) return [];
  if(!isMultiMode()){
    const m=Math.max(0,parseInt(el.roiMargin.value,10)||0);
    return [{x:m,y:m,w:vw-2*m,h:vh-2*m}];
  }
  const rows=Math.max(1,Math.min(6,parseInt(el.rows.value,10)||2));
  const cols=Math.max(1,Math.min(6,parseInt(el.cols.value,10)||2));
  const m=Math.max(0,parseInt(el.roiMargin.value,10)||0);
  const slots=[]; const cellW=Math.floor(vw/cols), cellH=Math.floor(vh/rows);
  for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
    const x=c*cellW+m, y=r*cellH+m;
    const w=(c===cols-1? vw - c*cellW : cellW) - 2*m;
    const h=(r===rows-1? vh - r*cellH : cellH) - 2*m;
    if(w>20 && h>20) slots.push({x,y,w,h});
  }
  return slots;
}
function tickCam(){
  if(!camStream) return;
  const v=el.cam, c=el.camCanvas, ctx=c.getContext('2d');
  const w=v.videoWidth, h=v.videoHeight; if(!w||!h){ rafId=requestAnimationFrame(tickCam); return; }
  c.width=w; c.height=h;

  const now = performance.now();
  if(perf.rafLast){ pushSample(perf.rafSamples, now - perf.rafLast, 60); }
  perf.rafLast = now;

  const slots=getSlots(); if(!slots.length){ rafId=requestAnimationFrame(tickCam); return; }

  const usePool = USE_WORKERS && WORKERS.length && (!WORKERS_IN_MULTI_ONLY || isMultiMode());

  if(usePool){
    dispatchSlots(slots);
    const t = performance.now();
    detCache = detCache.filter(d => (t - d.ts) < DET_HOLD_MS);
    drawOverlayGrid();
    drawDetections(detCache.map(d => ({ corners:d.corners })));
    updateLog();
    rafId=requestAnimationFrame(tickCam);
    return;
  }

  const dets=[];
  if(!isMultiMode()){
    ctx.drawImage(v,0,0,w,h);
    const img=ctx.getImageData(0,0,w,h);
    const t0=performance.now();
    const code=jsQR(img.data,img.width,img.height,{inversionAttempts:'dontInvert'});
    const t1=performance.now();
    pushSample(perf.fallbackTimes, t1-t0, 50);
    if(code?.location){
      const L=code.location;
      dets.push({corners:[L.topLeftCorner,L.topRightCorner,L.bottomRightCorner,L.bottomLeftCorner]});
    }
    handleResult(code?.data, null);
  }else{
    for(let i=0;i<slots.length;i++){
      const s=slots[i];
      ctx.drawImage(v, s.x,s.y,s.w,s.h, 0,0,s.w,s.h);
      const img=ctx.getImageData(0,0,s.w,s.h);
      const t0=performance.now();
      const code=jsQR(img.data,img.width,img.height,{inversionAttempts:'dontInvert'});
      const t1=performance.now();
      pushSample(perf.fallbackTimes, t1-t0, 50);
      if(code?.location){
        const L=code.location, tg=p=>({x:p.x+s.x,y:p.y+s.y});
        dets.push({corners:[tg(L.topLeftCorner),tg(L.topRightCorner),tg(L.bottomRightCorner),tg(L.bottomLeftCorner)]});
      }
      handleResult(code?.data, i);
    }
  }
  drawDetections(dets);
  updateLog();
  rafId=requestAnimationFrame(tickCam);
}
function handleResult(str, slot){
  if(!str){
    if (slot!=null){
      const st = slotState.get(slot) || { curr:'', same:0 };
      st.curr=''; st.same=0; slotState.set(slot, st);
    } else {
      camD.curr=''; camD.same=0;
    }
    return;
  }

  const m = FRAME_RE.exec(str);
  if (m){
    const i = parseInt(m[1],10), payload = m[4];
    const dup = rx.got.has(i) && rx.got.get(i) === payload;
    if (!dup){
      if (isTextCamMode()) ingestText(str);
      else ingestB64(str);
    }
    if (slot!=null){
      const st = slotState.get(slot) || { curr:'', same:0 };
      st.curr=''; st.same=0; slotState.set(slot, st);
    } else {
      camD.curr=''; camD.same=0;
    }
    return;
  }

  const proc = (state) => {
    if (str === state.curr) state.same++;
    else { state.curr = str; state.same = 1; }

    if (state.same >= STABLE_FRAMES){
      const h = fp32(str), now = Date.now(), last = seen.get(h) || 0;
      if (now - last > DEDUPE_TTL){
        if (isTextCamMode()){
          ingestText(str);
          if (el.autoStopHL?.checked) stopScan();
        } else {
          ingestB64(str);
        }
        seen.set(h, now);
        state.same = 0;
      }
    }
  };

  if (slot!=null){
    const st = slotState.get(slot) || { curr:'', same:0 };
    proc(st); slotState.set(slot, st);
  } else {
    proc(camD);
  }
}

/* ====== 変換/入出力 ====== */
function convert(){
  const s=el.input?.value ?? '';
  if(!s.trim()){ alert('入力が空です'); return; }
  try{
    if (mode==='ENC'){
      const useZip = !!el.compressToggle?.checked;
      el.output.value = maybeCompressTextToB64(s, useZip);
    }else if (mode==='DEC'){
      el.output.value = decodeMaybeGzipToText(s);
    }else{
      el.output.value = (mode==='ENC') ? utf8ToB64(s) : b64ToUtf8(s);
    }
  }catch(e){
    alert('変換に失敗: '+e.message);
  }
}
function convertAndQR(){
  if(mode==='ENC'){ convert(); }
  if(buildSequence()){ /* 表示済み */ }
}
async function copyOut(){
  const s=el.output?.value; if(!s) return;
  try{ await navigator.clipboard.writeText(s); toast('コピーしました'); }
  catch(_){ toast('コピーできませんでした',true); }
}
async function shareOut(){
  const s=el.output?.value; if(!s) return;
  try{
    if(navigator.share){ await navigator.share({text:s}); }
    else{ await navigator.clipboard.writeText(s); toast('共有非対応→コピーしました'); }
  }catch{}
}
async function pasteTo(elm){
  try{
    const t=await navigator.clipboard.readText();
    if(!t){ toast('クリップボードが空です',true); return; }
    elm.value=t; toast('貼り付けました'); autoResize(elm);
  }catch(e){ toast('貼り付けを許可してください',true); }
}
function handleFiles(files){
  if(!files?.length) return;
  const f=files[0]; const r=new FileReader();
  r.onload=e=>{ const b64=(String(e.target.result).split(',')[1]||''); el.output.value=b64; toast(f.name+' をBase64化しました'); };
  r.readAsDataURL(f);
}
function saveFile(){
  const b64=el.input?.value.trim(); if(!b64){ alert('Base64を入力してください'); return; }
  const name=(el.filename?.value.trim()||'download'); const ext=el.filetype?.value||'bin';
  const mimeMap={ pdf:'application/pdf',docx:'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    xlsx:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', pptx:'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    png:'image/png', jpg:'image/jpeg', mp4:'video/mp4', exe:'application/vnd.microsoft.portable-executable', bin:'application/octet-stream' };
  try{
    const clean=normalizeB64(b64), bin=atob(clean); const arr=new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i);
    const blob=new Blob([arr],{type:mimeMap[ext]||'application/octet-stream'});
    const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`${name}.${ext}`;
    document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),1500);
  }catch(e){ alert('保存に失敗: '+e.message); }
}

/* Autosize */
function autoResize(ta){
  if(!ta) return;
  ta.style.height='auto'; ta.style.height = Math.min(600, Math.max(120, ta.scrollHeight))+'px';
}

/* ====== モード切替 ====== */
function setMode(to){
  stopScan();

  tabState[mode].in = el.input?.value ?? '';
  tabState[mode].out = el.output?.value ?? '';
  mode = to;

  [el.mEnc,el.mDec,el.mFile,el.mB2F,el.mCamB64,el.mCamTxt,el.mCamB64M,el.mCamTxtM].forEach(b=>b?.classList.remove('sel'));
  ({ENC:el.mEnc,DEC:el.mDec,FILE:el.mFile,B2F:el.mB2F,CAM_B64:el.mCamB64,CAM_TXT:el.mCamTxt,CAM_B64_MULTI:el.mCamB64M,CAM_TXT_MULTI:el.mCamTxtM})[mode]?.classList.add('sel');

  if(el.input)  el.input.value  = tabState[mode].in;
  if(el.output) el.output.value = tabState[mode].out;

  const isText=(mode==='ENC'||mode==='DEC');
  const isFile=(mode==='FILE');
  const isB2F =(mode==='B2F');

  el.panelInput.style.display  = (isText||isFile||isB2F)?'block':'none';
  el.panelOutput.style.display = 'block';

  el.input.style.display       = (isText||mode==='DEC'||mode==='ENC') ? 'block' : (isB2F ? 'block' : 'none');
  el.drop.style.display        = isFile ? 'block' : 'none';
  el.b2fRow.style.display      = isB2F ? 'flex' : 'none';
  el.inputActions.style.display= isText ? 'flex' : (isB2F?'none':'none');

  el.qrSend.style.display      = (!isCamMode()) ? 'block':'none';
  el.qrRecv.style.display      = isCamMode()    ? 'block':'none';
  if(isCamMode() && el.qrRecv.parentElement!==el.textIO){
    el.textIO.insertBefore(el.qrRecv, el.panelOutput);
  }

  el.autoStopWrap.style.display = isTextCamMode() ? 'flex' : 'none';
  el.gridOpts.style.display     = isMultiMode()   ? 'flex' : 'none';

  el.descText.textContent = ({
    ENC:DESC.ENC, DEC:DESC.DEC, FILE:DESC.FILE, B2F:DESC.B2F,
    CAM_B64:DESC.CAM_B64, CAM_TXT:DESC.CAM_TXT,
    CAM_B64_MULTI:DESC.CAM_B64_MULTI, CAM_TXT_MULTI:DESC.CAM_TXT_MULTI
  })[mode] || '';

  const showOutQR = (mode==='ENC' || mode==='DEC' || mode==='FILE');
  if (el.rowOutputRight) el.rowOutputRight.style.display = showOutQR ? 'flex' : 'none';

  const showWorkerOpt = (isCamMode() && isMultiMode());
  if (el.workerOpt) el.workerOpt.style.display = showWorkerOpt ? 'inline-flex' : 'none';

  if (el.compressOpt) el.compressOpt.style.display = (mode==='ENC') ? 'inline-flex' : 'none';

  if (!showWorkerOpt) teardownWorkers();
  else if (USE_WORKERS && WORKER_URL) ensurePoolSize(getDesiredPoolSize());

  autoResize(el.input); autoResize(el.output);
}
/* === PDF Progress helpers (追加) === */
const pdfProgress = {
  cancel:false,
  open(total, perPage){
    this.cancel = false;
    if (!el.pdfProg) return;
    el.pdfProg.classList.add('show');
    el.pdfProg.setAttribute('aria-hidden','false');
    if (el.pdfProgBar){
      el.pdfProgBar.max = Math.max(1, total|0);
      el.pdfProgBar.value = 0;
    }
    if (el.pdfProgLabel){
      const pages = Math.max(1, Math.ceil(total / Math.max(1, perPage)));
      el.pdfProgLabel.textContent = `0/${total} を生成中…（ページ 0/${pages}）`;
    }
  },
  async step(done, total, perPage){
    if (!el.pdfProg) return;
    const pages = Math.max(1, Math.ceil(total / Math.max(1, perPage)));
    const page = Math.min(pages, Math.floor((Math.max(1, done) - 1)/Math.max(1, perPage)) + 1);
    if (el.pdfProgBar){
      el.pdfProgBar.max = Math.max(1, total|0);
      el.pdfProgBar.value = Math.min(total, done);
    }
    if (el.pdfProgLabel){
      el.pdfProgLabel.textContent = `${done}/${total} を生成中…（ページ ${page}/${pages}）`;
    }
    await new Promise(requestAnimationFrame);
  },
  close(){
    if (!el.pdfProg) return;
    el.pdfProg.classList.remove('show');
    el.pdfProg.setAttribute('aria-hidden','true');
  },
  startPseudo(){
    this.cancel = false;
    if (!el.pdfProg) return;
    el.pdfProg.classList.add('show');
    el.pdfProg.setAttribute('aria-hidden','false');
    if (el.pdfProgBar){
      el.pdfProgBar.removeAttribute('max');
      el.pdfProgBar.removeAttribute('value');
    }
    if (el.pdfProgLabel){
      el.pdfProgLabel.textContent = 'PDF を準備中… この処理は 10〜30 秒ほどかかります';
    }
  }
};
/* ====== PDF出力 ====== */
function makeQrDataUrl(text, sizePx){
  return new Promise(resolve=>{
    const tmp = document.createElement('div');
    tmp.style.position='absolute';
    tmp.style.left='-99999px';
    tmp.style.top='-99999px';
    document.body.appendChild(tmp);

    new QRCode(tmp, { text, width:sizePx, height:sizePx, correctLevel:QRCode.CorrectLevel.M });

    setTimeout(()=>{
      const cv = tmp.querySelector('canvas');
      const img = tmp.querySelector('img');

      const finishFromCanvas = (canvas)=>{
        try{
          const url = canvas.toDataURL('image/png');
          tmp.remove();
          resolve(url);
        }catch(_){ tmp.remove(); resolve(''); }
      };

      if (cv){ finishFromCanvas(cv); return; }

      if (img){
        if (img.complete){
          const c=document.createElement('canvas');
          c.width=sizePx; c.height=sizePx;
          const ctx=c.getContext('2d');
          ctx.drawImage(img,0,0,sizePx,sizePx);
          finishFromCanvas(c);
        }else{
          img.onload = ()=>{
            const c=document.createElement('canvas');
            c.width=sizePx; c.height=sizePx;
            const ctx=c.getContext('2d');
            ctx.drawImage(img,0,0,sizePx,sizePx);
            finishFromCanvas(c);
          };
          img.onerror = ()=>{ tmp.remove(); resolve(''); };
        }
        return;
      }

      tmp.remove();
      resolve('');
    }, 0);
  });
}
function buildPrintChunks(rows, cols){
  const s = el.output?.value.trim() || '';
  if (!s){ alert('出力が空です'); return null; }

  const grid = Math.max(1, (parseInt(rows,10)||2) * (parseInt(cols,10)||4));
  const MAX_PER_QR = 700;
  const per = Math.max(1, Math.min(MAX_PER_QR, Math.ceil(s.length / grid)));

  const withHeader = !!(el.withHdr && el.withHdr.checked);
  return withHeader ? splitFrames(s, per) : splitFramesNoHeader(s, per);
}
async function makePDF(){
  if(!window.jspdf || !window.jspdf.jsPDF){
    alert('PDF生成ライブラリ(jsPDF)が読み込めませんでした'); return;
  }

  const rows = Math.max(1, parseInt(el.pdfRows?.value||'2',10));
  const cols = Math.max(1, parseInt(el.pdfCols?.value||'4',10));
  const margin = Math.max(0, parseFloat(el.pdfMargin?.value||'10'));
  const perPage = Math.max(1, rows * cols);

  const chunks = buildPrintChunks(rows, cols);
  if(!chunks || !chunks.length){
    pdfProgress.startPseudo();
    setTimeout(()=>pdfProgress.close(), 1200);
    return;
  }

  const total = chunks.length;

  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ unit:'mm', format:'a4' });

  const pageW = doc.internal.pageSize.getWidth();
  const pageH = doc.internal.pageSize.getHeight();
  const gridW = Math.max(0, pageW - 2*margin);
  const gridH = Math.max(0, pageH - 2*margin);
  const cellW = gridW / cols;
  const cellH = gridH / rows;

  const labelH = 8;
  const gap    = 2;
  const pad    = 2;
  const qrSizeMm = Math.max(14, Math.min(cellW - pad*2, cellH - (labelH + gap) - pad*2));

  const pxPerMm = 9.5;
  const qrSizePx = Math.round(qrSizeMm * pxPerMm);

  pdfProgress.open(total, perPage);

  try{
    for (let i=0;i<total;i++){
      if (pdfProgress.cancel){
        pdfProgress.close();
        toast('PDF生成をキャンセルしました', true);
        return;
      }

      if (i>0 && i % perPage === 0){
        doc.addPage();
      }

      const idxOnPage = i % perPage;
      const r = Math.floor(idxOnPage / cols);
      const c = idxOnPage % cols;

      const x0 = margin + c*cellW + pad;
      const y0 = margin + r*cellH + pad;
      const innerW = cellW - pad*2;
      const innerH = cellH - pad*2;

      const qrX = x0 + (innerW - qrSizeMm)/2;
      const qrY = y0 + (innerH - (qrSizeMm + gap + labelH))/2;

      const dataUrl = await makeQrDataUrl(chunks[i], qrSizePx);
      if (dataUrl){
        doc.addImage(dataUrl, 'PNG', qrX, qrY, qrSizeMm, qrSizeMm);
      }

      const labelY = qrY + qrSizeMm + gap + (labelH/2);
      doc.setFontSize(12);
      doc.text(`${i+1}/${total}`, x0 + innerW/2, labelY, { align:'center', baseline:'middle' });

      await pdfProgress.step(i+1, total, perPage);
    }

    const ts = new Date().toISOString().replace(/[-:T]/g,'').slice(0,12);
    doc.save(`qr_${rows}x${cols}_${ts}.pdf`);
  }catch(e){
    alert('PDF生成に失敗: ' + e.message);
  }finally{
    pdfProgress.close();
  }
}


/* ====== イベント ====== */
on(el.mEnc,'click',()=>setMode('ENC'));
on(el.mDec,'click',()=>setMode('DEC'));
on(el.mFile,'click',()=>setMode('FILE'));
on(el.mB2F,'click',()=>setMode('B2F'));
on(el.mCamB64,'click',()=>setMode('CAM_B64'));
on(el.mCamTxt,'click',()=>setMode('CAM_TXT'));
on(el.mCamB64M,'click',()=>setMode('CAM_B64_MULTI'));
on(el.mCamTxtM,'click',()=>setMode('CAM_TXT_MULTI'));

on(el.btnConvert,'click',convert);
on(el.btnConvertQR,'click',convertAndQR);

/* 出力側 QR 表示ボタン */
on(el.btnQRShow,'click',()=>{ buildSequence(); });

on(el.input,'keydown',e=>{
  if((e.ctrlKey||e.metaKey) && e.key==='Enter'){ e.preventDefault(); convert(); }
  if(e.shiftKey && e.key==='Enter'){ e.preventDefault(); convertAndQR(); }
  setTimeout(()=>autoResize(el.input),0);
});
on(el.output,'input',()=>autoResize(el.output));

on(el.btnCopy,'click',copyOut);
on(el.btnShare,'click',shareOut);

on(el.btnPasteText,'click',()=>pasteTo(el.input));
on(el.btnClearText,'click',()=>{ el.input.value=''; autoResize(el.input); });

on(el.btnPaste,'click',()=>pasteTo(el.input));
on(el.btnClear,'click',()=>{ el.input.value=''; autoResize(el.input); });
on(el.btnSave,'click',saveFile);

on(el.fileBtn,'click',()=>el.fileInput?.click());
on(el.fileInput,'change',()=>handleFiles(el.fileInput?.files));
on(el.drop,'dragover',e=>{ e.preventDefault(); });
on(el.drop,'drop',e=>{ e.preventDefault(); handleFiles(e.dataTransfer?.files); });

on(el.btnPrev,'click',()=>{ if(idx>0){ idx--; el.scrub.value=idx; renderQR(); updateTime(); }});
on(el.btnNext,'click',()=>{ if(idx<qrChunks.length-1){ idx++; el.scrub.value=idx; renderQR(); updateTime(); }});
on(el.btnPlay,'click',()=>{
  playing=!playing;
  el.btnPlay.querySelector('.material-symbols-outlined').textContent = playing?'pause':'play_arrow';
  if(playing) tickPlay();
});
on(el.scrub,'input',()=>{ idx=parseInt(el.scrub.value||'0',10)||0; renderQR(); updateTime(); });
function setFps(v){
  let val=parseFloat(v); if(isNaN(val)) val=2.0;
  val=Math.max(0.2, Math.min(120, val));
  el.fps.value=String(val); el.fpsNum.value=val.toFixed(1); fpsRate=val; updateTime();
  if(playing){ playing=false; el.btnPlay.querySelector('.material-symbols-outlined').textContent='play_arrow';
    setTimeout(()=>{ playing=true; el.btnPlay.querySelector('.material-symbols-outlined').textContent='pause'; tickPlay(); },0);
  }
}
on(el.btnMakePDF, 'click', makePDF);
on(el.btnPDFCancel, 'click', ()=>{ pdfProgress.cancel = true; });

on(el.fps,'input',()=>setFps(el.fps.value));
on(el.fpsNum,'input',()=>setFps(el.fpsNum.value));
on(el.fpsNum,'change',()=>setFps(el.fpsNum.value));

on(el.btnScanStart,'click',startScan);
on(el.btnScanStop,'click',stopScan);
el.cam.addEventListener('loadedmetadata',()=>{ ensureOverlaySize(); drawOverlayGrid(); });
window.addEventListener('resize',()=>{ ensureOverlaySize(); drawOverlayGrid(); });

if(navigator.share){ el.btnShare.style.display='inline-flex'; }

/* 簡易ログ：表示切替＆✕ボタン */
on(el.logToggle,'change', ()=>{
  el.logPanel.style.display = el.logToggle.checked ? 'block' : 'none';
  el.logPanel.setAttribute('aria-hidden', el.logToggle.checked ? 'false':'true');
  updateLog();
});
on(el.logClose,'click', ()=>{
  el.logToggle.checked = false;
  el.logPanel.style.display = 'none';
  el.logPanel.setAttribute('aria-hidden','true');
});

/* Workerトグル */
on(el.workerToggle,'change', ()=>{
  USE_WORKERS = !!el.workerToggle.checked;
  if (USE_WORKERS){
    if (!(isCamMode() && isMultiMode())){
      toast('Workerは「QR複数」入力モードでのみ使用されます');
      return;
    }
    initWorkers();
    if (camStream && WORKER_URL) ensurePoolSize(getDesiredPoolSize());
  }else{
    teardownWorkers();
  }
});

/* Help */
function openHelp(){
  el.helpModal.classList.add('show'); el.helpModal.setAttribute('aria-hidden','false');
  if(el.helpQR && !el.helpQR.dataset.ready && typeof QRCode!=='undefined'){
    el.helpQR.innerHTML=''; new QRCode(el.helpQR,{text:'suzuki.yuya.kitasato@gmail.com',width:110,height:110,correctLevel:QRCode.CorrectLevel.M});
    el.helpQR.dataset.ready='1';
  }
}
function closeHelp(){ el.helpModal.classList.remove('show'); el.helpModal.setAttribute('aria-hidden','true'); }
on(el.btnHelp,'click',openHelp);
on(el.btnHelpClose,'click',closeHelp);
el.helpModal.addEventListener('click', e=>{ if(e.target===el.helpModal) closeHelp(); });

/* === グローバル・キーボードショートカット（プレイヤー系/ヘルプ/Esc） === */
function isEditableTarget(t){
  if(!t) return false;
  const tag = (t.tagName||'').toLowerCase();
  return t.isContentEditable || tag==='input' || tag==='textarea' || tag==='select';
}
function isVisible(elem){
  if(!elem) return false;
  const s = window.getComputedStyle(elem);
  return s.display !== 'none' && s.visibility !== 'hidden';
}
document.addEventListener('keydown', (e)=>{
  const key = e.key;

  // ヘルプ（F1）
  if (key === 'F1'){
    e.preventDefault();
    openHelp();
    return;
  }

  // Esc: モーダル類を閉じる（ヘルプ／PDF進捗）
  if (key === 'Escape'){
    if (el.helpModal?.classList.contains('show')) { e.preventDefault(); closeHelp(); return; }
    if (el.pdfProg?.classList.contains('show'))  { e.preventDefault(); el.btnPDFCancel?.click(); return; }
    return;
  }

  // プレイヤー系は送信パネルが見えているときにのみ
  if (!isVisible(el.qrSend)) return;
  // ヘルプが開いていたらプレイヤーショートカットは効かせない
  if (el.helpModal?.classList.contains('show')) return;

  // 入力中のUIでは邪魔しない（Esc/F1は上で処理済み）
  if (isEditableTarget(e.target)) return;

  // 再生/移動
  if (key === ' ' || key === 'Spacebar'){
    e.preventDefault();
    el.btnPlay?.click();
    return;
  }
  if (key === 'ArrowRight'){
    e.preventDefault();
    el.btnNext?.click();
    return;
  }
  if (key === 'ArrowLeft'){
    e.preventDefault();
    el.btnPrev?.click();
    return;
  }
  if (key === 'Home'){
    if (qrChunks.length){
      e.preventDefault();
      idx = 0; el.scrub.value = 0; renderQR(); updateTime();
    }
    return;
  }
  if (key === 'End'){
    if (qrChunks.length){
      e.preventDefault();
      idx = Math.max(0, qrChunks.length-1);
      el.scrub.value = idx; renderQR(); updateTime();
    }
    return;
  }
});

setMode('ENC');
setFps(2);
autoResize(el.input); autoResize(el.output);
});

/* トースト */
function toast(msg,bad=false){
  const d=document.createElement('div');
  d.textContent=msg;
  d.style.cssText='position:fixed;left:50%;bottom:22px;transform:translateX(-50%);padding:8px 12px;border-radius:8px;color:#fff;z-index:9999;opacity:.95;background:'+(bad?'#d32f2f':'#333');
  document.body.appendChild(d); setTimeout(()=>d.remove(),1400);
}
</script>
<!-- PDF Progress Modal (追加) -->
<div id="pdf-progress" class="modal" aria-hidden="true">
  <div class="box" role="dialog" aria-modal="true" aria-labelledby="pdf-pr-title" style="max-width:460px">
    <div class="topbar" style="border:none;margin-bottom:4px">
      <h2 id="pdf-pr-title" style="margin:0;font-size:16px">PDF を準備中…</h2>
      <button id="btn-pdf-cancel" class="btn-err">キャンセル</button>
    </div>
    <div class="content" style="display:flex;flex-direction:column;gap:10px">
      <div id="pdf-pr-label" class="muted">0/0 を生成中…</div>
      <progress id="pdf-pr-bar" max="100" value="0" style="width:100%"></progress>
      <div class="muted" style="font-size:12px">この処理は 10〜30 秒ほどかかります。</div>
    </div>
  </div>
</div>
</body>
</html>
