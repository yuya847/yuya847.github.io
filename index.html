<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>QR B64ブリッジ</title>

<link rel="icon" href="/favicon.svg" type="image/svg+xml">
<link rel="apple-touch-icon" href="/apple-touch-icon-180.png" sizes="180x180">
<meta name="theme-color" content="#0d47a1">

<style>
/* ===== Material palette ===== */
:root{
  --fg:#222; --bg:#fff; --muted:#666; --br:#dde1e5;
  --md-pri:#0d47a1;   /* indigo 900 */
  --md-acc:#039be5;   /* light blue 600 */
  --md-err:#d32f2f;   /* red 700 */
  --md-light:#81d4fa; /* light blue 200 */
  --md-surf:#eceff1;  /* blue grey 50 */
  --btn-radius:10px;
}

html,body{height:100%}
body{margin:0;font-family:Meiryo,"Yu Gothic",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--fg);background:var(--bg);display:flex;flex-direction:column}

/* ===== Header ===== */
header{background:var(--md-pri);color:#fff}
.header-row{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px 16px}
header h1{margin:0;font-size:16px;letter-spacing:.02em}
.header-actions{display:flex;align-items:center;gap:8px}
.badge{display:inline-block;background:rgba(255,255,255,.16);color:#fff;padding:4px 8px;border-radius:999px;font-size:12px;border:1px solid rgba(255,255,255,.2)}

/* ===== Layout ===== */
.container{padding:12px;display:flex;flex-direction:column;gap:12px}

/* ===== Mode tabs: 常時 4×2 グリッド ===== */
.mode{display:flex}
.seg{
  display:grid; grid-template-columns:repeat(4,minmax(0,1fr));
  gap:8px; padding:8px; border:1px solid var(--br); border-radius:14px; background:#fff; width:100%;
}
.seg button{
  padding:8px 10px; border:1px solid var(--br); border-radius:999px;
  background:#fff; color:#1c1c1c; cursor:pointer; font-size:14px;
  transition:filter .12s ease, box-shadow .15s ease, transform .06s ease;
}
.seg button.sel{background:var(--md-light); color:#0a2c63; border-color:#b3e5fc; font-weight:700}
.seg button:hover:not(.sel){filter:brightness(1.03);transform:translateY(-1px);box-shadow:0 2px 8px rgb(0 0 0 / .12)}
.seg button:active{transform:translateY(0);box-shadow:0 1px 3px rgb(0 0 0 / .2)}
.seg button .short{display:none}
.seg button .full{display:inline}

/* ===== Panels ===== */
.grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
.grid.single{grid-template-columns:1fr} /* B2F時は片カラムに */
@media(max-width:900px){ .grid{grid-template-columns:1fr} }
.panel{border:1px solid var(--br);border-radius:12px;padding:12px;background:#fff;display:flex;flex-direction:column;gap:8px}
.panel h2{margin:0;font-size:15px}
textarea{width:100%;min-height:220px;resize:vertical;font-size:16px;line-height:1.5;padding:10px;box-sizing:border-box;border:1px solid #cfd8dc;border-radius:10px;background:#fff}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.row.right{justify-content:flex-end}
.row.split{justify-content:space-between;align-items:center}

.card{border:1px dashed #cfd8dc;border-radius:12px;padding:10px;background:#fbfdff}
#drop-zone.big{min-height:240px;display:flex;align-items:center;justify-content:center;font-size:15px}
.muted{color:var(--muted);font-size:13px}

/* ===== Buttons ===== */
button,select,input[type="text"],input[type="file"],input[type="number"]{
  font-size:15px;padding:9px 12px;border:1px solid #cfd8dc;border-radius:var(--btn-radius);background:#fff;color:#1f2937;
}
button{cursor:pointer;transition:background-color .15s ease,transform .06s ease,box-shadow .15s ease,filter .15s ease}
button:hover:not(:disabled){transform:translateY(-1px);box-shadow:0 2px 8px rgb(0 0 0 / .12);filter:brightness(1.03)}
button:active:not(:disabled){transform:translateY(0);box-shadow:0 1px 3px rgb(0 0 0 / .2);filter:brightness(0.98)}
button:focus-visible{outline:3px solid #90caf9;outline-offset:2px}
button:disabled{opacity:.6;cursor:default}

/* Variants */
.btn-primary{background:var(--md-pri);color:#fff;border-color:transparent}
.btn-accent {background:var(--md-acc);color:#fff;border-color:transparent}
.btn-danger {background:var(--md-err);color:#fff;border-color:transparent}
.btn-surface{background:var(--md-surf);color:#0a2c63;border-color:#dfe6eb}
.btn-link{background:#fff;color:var(--md-acc);border-color:transparent;padding:6px 4px}

/* Ripple */
button.ripple{--ripple-x:50%;--ripple-y:50%;--ripple-color:rgba(255,255,255,.35);background-image:radial-gradient(circle at var(--ripple-x) var(--ripple-y),var(--ripple-color) 0,var(--ripple-color) 10%,transparent 11%);background-repeat:no-repeat;background-size:0 0}
button.rippling{background-size:200% 200%}

/* Range/FPS */
input[type="range"]{width:100%}
input[type="range"]::-webkit-slider-thumb{transition:transform .12s ease}
input[type="range"]:hover::-webkit-slider-thumb,input[type="range"]:focus-visible::-webkit-slider-thumb{transform:scale(1.2)}
input[type="range"]::-moz-range-thumb{transition:transform .12s ease}
input[type="range"]:hover::-moz-range-thumb,input[type="range"]:focus-visible::-moz-range-thumb{transform:scale(1.2)}
.fps-wrap input[type="number"]{width:92px;text-align:right}

/* Sender QR */
.qr-wrap{display:flex;align-items:center;justify-content:center;height:340px;background:#fff;border:1px solid #e5e9ef;border-radius:12px;overflow:hidden}
.qr-controls{display:flex;flex-direction:column;gap:10px}
.qr-scrub{display:flex;align-items:center;gap:8px}
.qr-bottom{display:flex;align-items:center;gap:12px;justify-content:center;flex-wrap:wrap}
.time{min-width:60px;text-align:right;font-variant-numeric:tabular-nums}
.range{flex:1}
.nohdr{display:flex;align-items:center;gap:6px}

/* Camera / overlay */
.cam-wrap{display:flex;flex-direction:column;gap:10px}
.video-box{position:relative}
video#cam{width:100%;max-height:320px;background:#000;border-radius:12px;display:block}
canvas.overlay{position:absolute;inset:0;width:100%;height:100%;pointer-events:none}

/* Help modal */
.modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:10000}
.modal.show{display:flex}
.modal .box{width:min(900px,92vw);max-height:86vh;overflow:auto;background:#fff;border-radius:14px;padding:14px 16px;box-shadow:0 12px 30px rgba(0,0,0,.22)}
.modal .topbar{display:flex;justify-content:space-between;align-items:center;gap:8px;border-bottom:1px solid var(--br);padding-bottom:8px;margin-bottom:10px}
.modal .btn-close{background:#f2f5f7}
.modal .sec{margin:12px 0}
.modal h3{margin:6px 0 4px}
.modal ul{margin:6px 0 6px 1.2em;padding:0}
.qr-contact{display:flex;gap:12px;align-items:center}
.qr-cell{width:120px;height:120px;border:1px solid #e5e9ef;border-radius:10px;display:flex;align-items:center;justify-content:center;background:#fff}
kbd{background:#f2f3f7;border:1px solid #dcdfe6;border-bottom-width:2px;border-radius:4px;padding:0 6px;font-family:ui-monospace,Menlo,Consolas,monospace}

/* Mobile size tweaks */
@media (max-width:640px){
  .seg button{font-size:12px;padding:7px 8px}
  .seg button .full{display:none}
  .seg button .short{display:inline}
  textarea{min-height:180px}
}
@media (max-width:360px){
  .seg{grid-template-columns:repeat(3,minmax(0,1fr))}
  .seg button{font-size:11.5px;padding:6px 6px}
}

@media (prefers-reduced-motion: reduce){*{transition:none !important;animation:none !important;}}
button[data-tip]::after, button[data-tip]::before { display:none !important; }
</style>

<!-- Libs -->
<script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js" defer></script>
</head>
<body>
<header>
  <div class="header-row">
    <h1>テキストQRコード変換</h1>
    <div class="header-actions">
      <span id="ver" class="badge" title="バージョン"></span>
      <button id="btn-help" class="btn-surface ripple">ヘルプ</button>
    </div>
  </div>
</header>

<div class="container">
  <!-- Mode tabs -->
  <div class="mode">
    <div class="seg" role="tablist" aria-label="mode">
      <button id="m-enc" class="sel" role="tab" aria-label="テキストからBase64へ">
        <span class="full">テキスト → Base64</span><span class="short">Aa→B64</span>
      </button>
      <button id="m-dec" role="tab" aria-label="Base64からテキストへ">
        <span class="full">Base64 → テキスト</span><span class="short">B64→Aa</span>
      </button>
      <button id="m-file" role="tab" aria-label="ファイルからBase64へ">
        <span class="full">ファイル → Base64</span><span class="short">📁→B64</span>
      </button>
      <button id="m-b2f" role="tab" aria-label="Base64からファイルへ">
        <span class="full">Base64 → ファイル</span><span class="short">B64→📁</span>
      </button>
      <button id="m-cam" role="tab" aria-label="QRからBase64へ">
        <span class="full">QR→Base64</span><span class="short">QR→B64</span>
      </button>
      <button id="m-camtxt" role="tab" aria-label="QRからテキストへ">
        <span class="full">QR→テキスト</span><span class="short">QR→Aa</span>
      </button>
      <button id="m-cam-multi" role="tab" aria-label="複数QRからBase64へ">
        <span class="full">QR（複数）→Base64</span><span class="short">QRs→B64</span>
      </button>
      <button id="m-camtxt-multi" role="tab" aria-label="複数QRからテキストへ">
        <span class="full">QR（複数）→テキスト</span><span class="short">QRs→Aa</span>
      </button>
    </div>
  </div>

  <!-- Text I/O -->
  <div class="grid" id="text-io">
    <!-- 入力 -->
    <section class="panel" id="panel-input">
      <h2>入力</h2>

      <!-- テキスト/DEC/B2Fで使う入力 -->
      <textarea id="input" placeholder="ここにテキストまたはBase64を入力…"></textarea>

      <!-- FILE モードのドロップ領域（入力欄は非表示にする） -->
      <div id="drop-zone" class="card" style="display:none;">
        <div class="muted">
          <strong>ファイルをドラッグ&ドロップ</strong> または
          <button id="btn-file-choose" class="btn-surface ripple">ファイル選択</button>
        </div>
        <input id="file-input" type="file" style="display:none"/>
      </div>

      <!-- ENC/DECで見せる貼り付け -->
      <div id="row-paste" class="row">
        <button id="btn-paste" class="btn-surface ripple">クリップボードをペースト</button>
        <span class="muted">※ テキスト↔B64 / B64→📁 で表示</span>
      </div>

      <!-- B2F専用：左にペースト＆クリア、右に保存UI -->
      <div id="row-b2f" class="row split" style="display:none;">
        <div class="row">
          <button id="btn-paste-b2f" class="btn-surface ripple">クリップボードをペースト</button>
          <button id="btn-clear-b2f" class="btn-danger ripple">クリア</button>
        </div>
        <div id="row-save-inline" class="row">
          <label>形式
            <select id="filetype">
              <option value="pdf">PDF</option>
              <option value="docx">Word (.docx)</option>
              <option value="xlsx">Excel (.xlsx)</option>
              <option value="pptx">PowerPoint (.pptx)</option>
              <option value="png">PNG</option>
              <option value="jpg">JPEG</option>
              <option value="mp4">MP4</option>
              <option value="exe">EXE</option>
              <option value="bin">バイナリ (.bin)</option>
            </select>
          </label>
          <input id="filename" type="text" placeholder="ファイル名（拡張子不要）"/>
          <button id="btn-save" class="btn-primary ripple">名前を付けて保存</button>
        </div>
      </div>

      <!-- 入力操作（B2F/FILEでは非表示に最適化） -->
      <div class="row right" id="row-actions">
        <button id="btn-conv-qr" class="btn-accent ripple" title="テキスト→B64 / ファイル→B64 をQRで連続表示">変換＋QRを表示（Shift+Enter）</button>
        <button id="btn-convert" class="btn-primary ripple">変換（Ctrl+Enter）</button>
        <button id="btn-clear" class="btn-danger ripple">クリア</button>
      </div>
    </section>

    <!-- 出力 -->
    <section class="panel" id="panel-output">
      <h2>出力</h2>
      <textarea id="output" placeholder="ここに結果が表示されます"></textarea>
      <div class="row" id="row-output-actions">
        <button id="btn-copy" class="btn-accent ripple">コピー</button>
        <button id="btn-qrshow" class="btn-accent ripple">QR表示（連続）</button>
      </div>
    </section>
  </div>

  <!-- Sender -->
  <section class="panel" id="qr-send">
    <h2>QRシーケンス出力</h2>
    <div class="qr-controls">
      <div class="qr-wrap" id="qr-display"></div>
      <div class="qr-scrub">
        <span id="elapsed" class="time">00:00</span>
        <input id="scrub" class="range" type="range" min="0" max="0" step="1" value="0"/>
        <span id="duration" class="time">00:00</span>
        <span id="frame-ind" class="muted">0 / 0</span>
      </div>
      <div class="qr-bottom">
        <button id="btn-prev" class="btn-surface ripple">⏮</button>
        <button id="btn-play" class="btn-surface ripple">▶</button>
        <button id="btn-next" class="btn-surface ripple">⏭</button>
        <div class="fps-wrap">
          <label>速度(FPS)
            <input id="fps" type="range" min="0.5" max="120" step="0.1" value="1.0"/>
          </label>
          <input id="fps-num" type="number" min="0.5" max="120" step="0.1" value="1.0"/>
        </div>
        <label class="nohdr">
          <input id="no-header" type="checkbox" checked>
          ヘッダなし（電子カルテ向け）
        </label>
      </div>
    </div>
  </section>

  <!-- Receiver -->
  <section class="panel" id="qr-recv" style="display:none;">
    <h2>QR入力</h2>
    <div class="cam-wrap">
      <div class="row">
        <button id="btn-scan-start" class="btn-primary ripple">カメラ開始</button>
        <button id="btn-scan-stop" class="btn-danger ripple">停止</button>
      </div>

      <!-- 目立たないオプション -->
      <details id="auto-stop-wrap" style="display:none;">
        <summary class="muted" style="cursor:pointer; user-select:none">オプション</summary>
        <label class="nohdr" style="opacity:.8; font-size:12px; margin-top:6px;">
          <input id="auto-stop-hl" type="checkbox">
          ヘッダなしは1枚読んだら自動停止（QR→テキスト）
        </label>
      </details>

      <!-- 複数ROI -->
      <div class="row" id="grid-opts" style="display:none;">
        <label>行: <input id="rows" type="number" min="1" max="6" value="2"></label>
        <label>列: <input id="cols" type="number" min="1" max="6" value="2"></label>
        <label>ROI余白(px): <input id="roi-margin" type="number" min="0" max="80" value="16"></label>
        <span class="muted">カルテ側のマス数に合わせてください（例: 2×2）。</span>
      </div>

      <div class="video-box">
        <video id="cam" playsinline muted></video>
        <canvas id="cam-overlay" class="overlay"></canvas>
      </div>
      <canvas id="cam-canvas" style="display:none"></canvas>

      <div class="muted">受信進捗（ヘッダ付き時）: <span id="rx-status">0/0</span></div>
    </div>
  </section>
</div>

<!-- Help modal -->
<div id="help-modal" class="modal" aria-hidden="true">
  <div class="box" role="dialog" aria-modal="true" aria-labelledby="help-title">
    <div class="topbar">
      <h2 id="help-title">ヘルプ</h2>
      <div class="row">
        <button id="btn-help-print" class="btn-surface ripple">印刷</button>
        <button id="btn-help-close" class="btn-surface ripple">閉じる</button>
      </div>
    </div>

    <div class="content">
      <div class="sec">
        <h3>概要</h3>
        <ul>
          <li>テキスト/ファイルをBase64に変換し、QRで送出・受信するツールです。</li>
          <li>DS9308などのスキャナ利用を想定。個人情報の扱いに注意してください。</li>
        </ul>
      </div>

      <div class="sec">
        <h3>モード</h3>
        <ul>
          <li><b>テキスト → B64</b>：<kbd>Ctrl</kbd>+<kbd>Enter</kbd> で変換。<b>変換＋QR</b>は <kbd>Shift</kbd>+<kbd>Enter</kbd>。</li>
          <li><b>ファイル → B64</b>：ドロップ/選択でBase64化 → 連続QR表示。</li>
          <li><b>B64 → ファイル</b>：Base64を復元して保存（拡張子: pdf/docx/xlsx/pptx/png/jpg/mp4/exe/bin）。</li>
          <li><b>QR→B64 / QR→テキスト</b>：単一QRの連続受信（検出ガイド表示）。</li>
          <li><b>QR（複数）→ …</b>：映像をグリッド分割して複数同時読み取り。</li>
        </ul>
      </div>

      <div class="sec"><h3>バージョン</h3><div id="about-version" class="muted"></div></div>
      <div class="sec muted">© Yuya Suzuki, Okazaki Medical Center</div>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
'use strict';
/* ===== Version ===== */
const APP_VERSION = 'ver 1.4';
const APP_BUILD   = '2025-08-10';
document.getElementById('ver').textContent = APP_VERSION;

/* ===== DOM ===== */
const $ = id => document.getElementById(id);
const on = (n,ev,fn)=>{ if(n) n.addEventListener(ev,fn,false); };

const el = {
  // tabs
  mEnc:$('m-enc'), mDec:$('m-dec'), mFile:$('m-file'), mB2F:$('m-b2f'),
  mCamB64:$('m-cam'), mCamTxt:$('m-camtxt'),
  mCamB64M:$('m-cam-multi'), mCamTxtM:$('m-camtxt-multi'),
  // panels
  textIO:$('text-io'), panelInput:$('panel-input'), panelOutput:$('panel-output'),
  // widgets
  input:$('input'), output:$('output'),
  drop:$('drop-zone'), fileBtn:$('btn-file-choose'), fileInput:$('file-input'),
  filename:$('filename'), filetype:$('filetype'),
  // rows / buttons
  rowActions:$('row-actions'), rowPaste:$('row-paste'), rowB2F:$('row-b2f'),
  btnPaste:$('btn-paste'), btnPasteB2F:$('btn-paste-b2f'), btnClearB2F:$('btn-clear-b2f'),
  btnClear:$('btn-clear'), btnCopy:$('btn-copy'), btnQR:$('btn-qrshow'),
  btnSave:$('btn-save'), btnConv:$('btn-convert'), btnConvQR:$('btn-conv-qr'),
  // sender
  qrSend:$('qr-send'), qrWrap:$('qr-display'), scrub:$('scrub'),
  elapsed:$('elapsed'), duration:$('duration'), frameInd:$('frame-ind'),
  btnPrev:$('btn-prev'), btnNext:$('btn-next'), btnPlay:$('btn-play'),
  fps:$('fps'), fpsNum:$('fps-num'), noHdr:$('no-header'),
  // recv
  qrRecv:$('qr-recv'), cam:$('cam'), camCanvas:$('cam-canvas'), camOverlay:$('cam-overlay'),
  btnScanStart:$('btn-scan-start'), btnScanStop:$('btn-scan-stop'),
  rxStatus:$('rx-status'),
  // options
  autoStopWrap:$('auto-stop-wrap'), autoStopHL:$('auto-stop-hl'),
  gridOpts:$('grid-opts'), rows:$('rows'), cols:$('cols'), roiMargin:$('roi-margin')
};

/* ===== Mode ===== */
let mode = 'ENC';
const tabState = {
  ENC:{in:'',out:''}, DEC:{in:'',out:''}, FILE:{in:'',out:''}, B2F:{in:'',out:''},
  CAM_B64:{in:'',out:''}, CAM_TXT:{in:'',out:''}, CAM_B64_MULTI:{in:'',out:''}, CAM_TXT_MULTI:{in:'',out:''}
};
const isCamMode = ()=> /^CAM_/.test(mode);
const isMulti   = ()=> mode==='CAM_B64_MULTI' || mode==='CAM_TXT_MULTI';
const isTextCam = ()=> mode==='CAM_TXT' || mode==='CAM_TXT_MULTI';

function syncOutputHeight(){
  // 入力欄の高さに合わせて出力欄の最小高さを調整（B2F/FILE/CAM以外）
  if(!el.input || !el.output) return;
  const need = !(isCamMode() || mode==='B2F' || mode==='FILE');
  el.output.style.minHeight = need ? (el.input.clientHeight+'px') : '';
}

function adjustFileDropHeight(){
  // FILEモード：出力と同じくらいにドロップ領域を大きく
  if(mode!=='FILE' || !el.drop || !el.output) return;
  el.drop.classList.add('big');
  const h = el.output.clientHeight || 240;
  el.drop.style.minHeight = Math.max(200, h)+'px';
}

function setMode(to){
  // 保存
  tabState[mode].in  = el.input?.value ?? '';
  tabState[mode].out = el.output?.value ?? '';
  mode = to;

  // タブ表示
  [el.mEnc,el.mDec,el.mFile,el.mB2F,el.mCamB64,el.mCamTxt,el.mCamB64M,el.mCamTxtM].forEach(b=>b&&b.classList.remove('sel'));
  ({ENC:el.mEnc,DEC:el.mDec,FILE:el.mFile,B2F:el.mB2F,CAM_B64:el.mCamB64,CAM_TXT:el.mCamTxt,CAM_B64_MULTI:el.mCamB64M,CAM_TXT_MULTI:el.mCamTxtM})[mode]?.classList.add('sel');

  // 値復元
  if (el.input)  el.input.value  = tabState[mode].in;
  if (el.output) el.output.value = tabState[mode].out;

  const isText=(mode==='ENC'||mode==='DEC');
  const isFile=(mode==='FILE');
  const isB2F =(mode==='B2F');
  const cam = isCamMode();

  // グリッド列（B2Fは片カラム）
  if (isB2F) el.textIO.classList.add('single'); else el.textIO.classList.remove('single');

  // 入力UI
  el.input.style.display      = (isText||mode==='DEC'||isB2F)?'block':'none'; // FILEでは非表示
  el.drop.style.display       = isFile?'block':'none';
  el.rowPaste.style.display   = isText?'flex':'none';
  el.rowB2F.style.display     = isB2F?'flex':'none';

  // 入力操作列
  el.btnConvQR.style.display  = (mode==='ENC'||mode==='FILE')?'inline-block':'none';
  el.btnConv.style.display    = isText?'inline-block':'none';
  el.btnClear.style.display   = isText?'inline-block':'none';
  if (isB2F){ el.btnConv.style.display='none'; el.btnClear.style.display='none'; }

  // 出力パネル
  el.panelOutput.style.display= isB2F ? 'none' : 'block';
  el.btnQR.style.display      = (!cam && !isB2F) ? 'inline-block' : 'none';

  // 送受信パネル
  el.qrSend.style.display     = (!cam && !isB2F) ? 'block' : 'none';
  el.qrRecv.style.display     = cam ? 'block':'none';
  if (cam && el.qrRecv.parentElement !== el.textIO) el.textIO.insertBefore(el.qrRecv, el.panelOutput);

  // オプション
  el.autoStopWrap.style.display = isTextCam() ? 'block' : 'none';
  el.gridOpts.style.display     = isMulti() ? 'flex' : 'none';

  // プレースホルダ
  el.output.placeholder = isFile ? 'ここにBase64が表示されます'
    : (mode==='DEC'||isTextCam()) ? 'ここにテキストが表示されます'
    : 'ここに結果が表示されます';

  // 調整
  syncOutputHeight();
  adjustFileDropHeight();
  drawOverlayGrid();
}

/* ===== Base64 ===== */
function utf8ToB64(str){
  if (window.TextEncoder){
    const bytes=new TextEncoder().encode(str); let bin=''; for(const b of bytes) bin+=String.fromCharCode(b); return btoa(bin);
  }
  return btoa(unescape(encodeURIComponent(str)));
}
function normalizeB64(b64){
  let s=(b64||'').trim();
  s=s.replace(/^data:.*;base64,/i,'').replace(/\s+/g,'').replace(/-/g,'+').replace(/_/g,'/');
  s+='='.repeat((4-(s.length%4))%4); return s;
}
function b64ToUtf8(b64){
  const clean=normalizeB64(b64);
  if (window.TextDecoder){
    const bin=atob(clean); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
    return new TextDecoder('utf-8').decode(bytes);
  }
  return decodeURIComponent(escape(atob(clean)));
}

/* ===== Sender (QR) ===== */
const fmtMMSS = x => { const t=Math.max(0,Math.floor(x)); const m=String(Math.floor(t/60)).padStart(2,'0'); const s=String(t%60).padStart(2,'0'); return `${m}:${s}`; };
const checksum = str => { let s=0; for(let i=0;i<str.length;i++) s=(s+str.charCodeAt(i))&0xffff; return s; };
const FRAME_RE=/^\[(\d+)\/(\d+)\|(\d+)\]([\s\S]*)$/;

let qrChunks=[], idx=0, playing=false, timer=null, fpsRate=1.0;
function splitFrames(text,maxPayload){
  const total=Math.ceil(text.length/maxPayload)||1; const frames=[];
  for(let i=0;i<total;i++){ const p=text.slice(i*maxPayload,(i+1)*maxPayload); frames.push(`[${i+1}/${total}|${checksum(p)}]${p}`); }
  return frames;
}
function splitFramesNoHeader(text,maxPayload){
  const total=Math.ceil(text.length/maxPayload)||1; const frames=[];
  for(let i=0;i<total;i++) frames.push(text.slice(i*maxPayload,(i+1)*maxPayload));
  return frames;
}
function buildSequence(){
  const s=el.output?.value.trim();
  if(!s){ alert('出力が空です'); return false; }
  if(typeof QRCode==='undefined'){ alert('QRCodeライブラリが読み込まれていません'); return false; }
  const maxPayload=700;
  const withHeader = !(el.noHdr && el.noHdr.checked);
  qrChunks = withHeader ? splitFrames(s,maxPayload) : splitFramesNoHeader(s,maxPayload);
  idx=0; el.scrub.max=Math.max(qrChunks.length-1,0); el.scrub.value=0;
  renderQR(); updateTimeLabels(); updateFrameInd();
  return true;
}
function renderQR(){ el.qrWrap.innerHTML=''; const text=qrChunks[idx]||''; new QRCode(el.qrWrap,{text,width:320,height:320,correctLevel:QRCode.CorrectLevel.M}); }
function updateTimeLabels(){ const total=qrChunks.length; const dur=total/fpsRate; const cur=(idx+1)/fpsRate; el.elapsed.textContent=fmtMMSS(cur); el.duration.textContent=fmtMMSS(dur); }
function updateFrameInd(){ el.frameInd.textContent=`${Math.min(idx+1,qrChunks.length)} / ${qrChunks.length}`; }
function play(){ if(playing||!qrChunks.length) return; playing=true; el.btnPlay.textContent='⏸'; tick(); }
function pause(){ playing=false; el.btnPlay.textContent='▶'; if(timer){ clearTimeout(timer); timer=null; } }
function tick(){ if(!playing) return; const interval=Math.max(1,Math.round(1000/fpsRate)); timer=setTimeout(()=>{ if(idx<qrChunks.length-1){ idx++; el.scrub.value=idx; renderQR(); updateTimeLabels(); updateFrameInd(); tick(); } else { pause(); } }, interval); }
function prev(){ if(idx>0){ idx--; el.scrub.value=idx; renderQR(); updateTimeLabels(); updateFrameInd(); } }
function next(){ if(idx<qrChunks.length-1){ idx++; el.scrub.value=idx; renderQR(); updateTimeLabels(); updateFrameInd(); } }
function setFps(val){
  const min=0.5, max=120; let v=parseFloat(val); if(isNaN(v)) v=1.0;
  v=Math.min(max,Math.max(min,v)); fpsRate=v;
  if (el.fps) el.fps.value=String(v); if(el.fpsNum) el.fpsNum.value=v.toFixed(1);
  updateTimeLabels(); if(playing){ pause(); play(); }
}

/* ===== Receiver ===== */
const rx = { total:0, got:new Map() };
const rxTxt = { buffer:'' };

function appendHeaderedAndMaybeComplete(frame){
  const m=FRAME_RE.exec(String(frame).trim()); if(!m) return {matched:false};
  const i=parseInt(m[1],10), total=parseInt(m[2],10), sum=parseInt(m[3],10), payload=m[4];
  if (checksum(payload)!==sum) { toast('チェックサム不一致',true); return {matched:true,ok:false}; }
  if (!rx.total) rx.total=total; if (rx.total!==total){ toast('総フレーム数が一致しません',true); return {matched:true,ok:false}; }
  const already = rx.got.has(i) && rx.got.get(i)===payload;
  rx.got.set(i,payload);
  if (el.rxStatus) el.rxStatus.textContent=`${rx.got.size}/${rx.total}`;
  if (already) return {matched:true,ok:true,complete:false};
  if (rx.got.size===rx.total){
    const parts=[]; for(let k=1;k<=rx.total;k++){ const p=rx.got.get(k); if(typeof p!=='string'){ toast(`欠落: ${k}`,true); return {matched:true,ok:false}; } parts.push(p); }
    const joined=parts.join(''); rx.total=0; rx.got.clear(); if(el.rxStatus) el.rxStatus.textContent='0/0';
    return {matched:true,ok:true,complete:true,payload:joined};
  }
  return {matched:true,ok:true,complete:false};
}
function ingestFrameToB64(text){
  const r=appendHeaderedAndMaybeComplete(text);
  if(!r.matched){ el.output.value += text; }
  else if(r.complete){ el.output.value = r.payload; }
}
function ingestFrameToText(text){
  const r=appendHeaderedAndMaybeComplete(text);
  if(!r.matched){ rxTxt.buffer += text; try{ el.output.value = b64ToUtf8(rxTxt.buffer); }catch(_){/*wait*/} }
  else if(r.complete){ try{ el.output.value = b64ToUtf8(r.payload); }catch(_){ toast('テキストに復号できませんでした',true); } }
}
function toast(msg,bad=false){
  const d=document.createElement('div');
  d.textContent=msg;
  d.style.cssText=`position:fixed;left:50%;bottom:24px;transform:translateX(-50%);
    padding:8px 12px;border-radius:10px;color:#fff;background:${bad?'#d32f2f':'#333'};
    z-index:9999;opacity:.95;box-shadow:0 6px 16px rgba(0,0,0,.25)`;
  document.body.appendChild(d); setTimeout(()=>d.remove(),1400);
}

/* Camera + overlay */
let camStream=null, rafId=null;
const STABLE_FRAMES=2, DEDUPE_TTL_MS=8000;
const camD={curr:'',same:0}; const slotState=new Map(); const seenHashes=new Map();
function fp32(s){ let h=0x811c9dc5|0; for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h += (h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24); } return h>>>0; }

async function startScan(){
  if(typeof jsQR==='undefined'){ alert('jsQRが読み込まれていません'); return; }
  if(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia){ alert('このブラウザはカメラ未対応です'); return; }
  try{
    camStream = await navigator.mediaDevices.getUserMedia({
      video:{facingMode:'environment', width:{ideal:1920}, height:{ideal:1080}}, audio:false
    });
    el.cam.srcObject = camStream;
    await el.cam.play();
    ensureOverlaySize(true);
    drawOverlayGrid();
    if (!rafId) tickCam(); // 二重起動防止
  }catch(e){ alert('カメラ起動に失敗: '+e.message); }
}
function stopScan(){
  if(camStream){ camStream.getTracks().forEach(t=>t.stop()); camStream=null; }
  if(rafId){ cancelAnimationFrame(rafId); rafId=null; }
  // オーバーレイは残す（ユーザーが状態を把握できるように）
}
function ensureOverlaySize(force=false){
  const vw=el.cam.videoWidth||0, vh=el.cam.videoHeight||0;
  if(!vw||!vh) return;
  if(force || el.camOverlay.width!==vw || el.camOverlay.height!==vh){
    const c=el.camOverlay; c.width=vw; c.height=vh;
    c.style.width  = el.cam.clientWidth+'px';
    c.style.height = el.cam.clientHeight+'px';
  }
}
function drawOverlayGrid(){
  const ctx=el.camOverlay.getContext('2d');
  ctx.clearRect(0,0,el.camOverlay.width,el.camOverlay.height);
  if (!isMulti()) return;
  const rows=Math.max(1,Math.min(6,parseInt(el.rows.value,10)||2));
  const cols=Math.max(1,Math.min(6,parseInt(el.cols.value,10)||2));
  const w=el.camOverlay.width, h=el.camOverlay.height;
  ctx.strokeStyle='rgba(3,155,229,0.9)'; ctx.lineWidth=2;
  for(let r=1;r<rows;r++){ const y=Math.round(h*r/rows)+.5; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
  for(let c=1;c<cols;c++){ const x=Math.round(w*c/cols)+.5; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
}
function drawDetections(dets){
  const ctx=el.camOverlay.getContext('2d');
  drawOverlayGrid();
  for(const d of dets){
    const pts=d.corners;
    ctx.save(); ctx.lineWidth=4; ctx.strokeStyle='rgba(16,185,129,0.95)';
    ctx.shadowColor='rgba(0,0,0,0.45)'; ctx.shadowBlur=4;
    ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y); for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x,pts[i].y);
    ctx.closePath(); ctx.stroke();
    ctx.fillStyle='rgba(16,185,129,0.95)'; for(const p of pts){ ctx.beginPath(); ctx.arc(p.x,p.y,3,0,Math.PI*2); ctx.fill(); }
    ctx.restore();
  }
}
function getSlots(){
  const vw=el.cam.videoWidth, vh=el.cam.videoHeight;
  if(!vw||!vh) return [];
  if(!isMulti()){
    const m=Math.max(0,parseInt(el.roiMargin.value,10)||0);
    return [{x:m,y:m,w:vw-2*m,h:vh-2*m}];
  }
  const rows=Math.max(1,Math.min(6,parseInt(el.rows.value,10)||2));
  const cols=Math.max(1,Math.min(6,parseInt(el.cols.value,10)||2));
  const m=Math.max(0,parseInt(el.roiMargin.value,10)||0);
  const slots=[]; const cellW=Math.floor(vw/cols), cellH=Math.floor(vh/rows);
  for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
    const x=c*cellW+m, y=r*cellH+m;
    const w=(c===cols-1? vw - c*cellW : cellW) - 2*m;
    const h=(r===rows-1? vh - r*cellH : cellH) - 2*m;
    if(w>20 && h>20) slots.push({x,y,w,h});
  }
  return slots;
}
function tickCam(){
  if(!camStream){ rafId=null; return; }
  const v=el.cam, c=el.camCanvas, ctx=c.getContext('2d');
  const w=v.videoWidth, h=v.videoHeight;
  if(!w||!h){ // メタデータ未到達の間は待機
    rafId=requestAnimationFrame(tickCam);
    return;
  }
  c.width=w; c.height=h;
  ensureOverlaySize(); // 動的リサイズにも追従

  const slots=getSlots(); if(!slots.length){ rafId=requestAnimationFrame(tickCam); return; }
  const dets=[];

  if(!isMulti()){
    ctx.drawImage(v,0,0,w,h);
    const img=ctx.getImageData(0,0,w,h);
    const code=jsQR(img.data,img.width,img.height,{inversionAttempts:'dontInvert'});
    if(code && code.location){
      const L=code.location; dets.push({corners:[L.topLeftCorner,L.topRightCorner,L.bottomRightCorner,L.bottomLeftCorner]});
    }
    handleQrResult(code && code.data, null);
  }else{
    for(let i=0;i<slots.length;i++){
      const s=slots[i];
      ctx.drawImage(v, s.x, s.y, s.w, s.h, 0, 0, s.w, s.h);
      const img=ctx.getImageData(0,0,s.w,s.h);
      const code=jsQR(img.data,img.width,img.height,{inversionAttempts:'dontInvert'});
      if(code && code.location){
        const L=code.location, tg=p=>({x:p.x+s.x,y:p.y+s.y});
        dets.push({corners:[tg(L.topLeftCorner),tg(L.topRightCorner),tg(L.bottomRightCorner),tg(L.bottomLeftCorner)]});
      }
      handleQrResult(code && code.data, i);
    }
  }

  drawDetections(dets);
  rafId=requestAnimationFrame(tickCam);
}
function handleQrResult(str,slot){
  if(!str){ if(slot!=null){ const st=slotState.get(slot)||{curr:'',same:0}; st.curr=''; st.same=0; slotState.set(slot,st); } else { camD.curr=''; camD.same=0; } return; }
  const m=FRAME_RE.exec(str);
  if(m){
    const i=parseInt(m[1],10), payload=m[4];
    const dup = rx.got.has(i) && rx.got.get(i)===payload;
    if(!dup){ if(isTextCam()) ingestFrameToText(str); else ingestFrameToB64(str); }
    if(slot!=null){ const st=slotState.get(slot)||{curr:'',same:0}; st.curr=''; st.same=0; slotState.set(slot,st); } else { camD.curr=''; camD.same=0; }
    return;
  }
  // headerless stability + TTL
  const nowProc = (obj)=>{
    if(str===obj.curr) obj.same++; else { obj.curr=str; obj.same=1; }
    if(obj.same>=STABLE_FRAMES){
      const h=fp32(str), now=Date.now(), last=seenHashes.get(h)||0;
      if(now-last>DEDUPE_TTL_MS){
        if(isTextCam()){
          ingestFrameToText(str);
          if(el.autoStopHL && el.autoStopHL.checked) stopScan();
        } else ingestFrameToB64(str);
        seenHashes.set(h,now); obj.same=0;
      }
    }
  };
  if(slot!=null){ const st=slotState.get(slot)||{curr:'',same:0}; nowProc(st); slotState.set(slot,st); }
  else nowProc(camD);
}

/* ===== Convert / I/O ===== */
function convert(){
  const s=el.input?.value.trim(); if(!s){ alert('入力が空です'); return; }
  try{ el.output.value = (mode==='ENC') ? utf8ToB64(s) : b64ToUtf8(s); }
  catch(e){ alert('変換に失敗: '+e.message+'\n\n※Base64は改行/URL-safe可、data:ヘッダは自動除去'); }
}
function convertAndShow(){
  if(mode==='ENC'){ convert(); }
  if(buildSequence()){ pause(); renderQR(); el.qrSend?.scrollIntoView({behavior:'smooth',block:'nearest'}); }
}
async function copyOut(){
  const s=el.output?.value; if(!s) return;
  try{ await navigator.clipboard.writeText(s); toast('コピーしました'); }
  catch(_){ const ta=el.output; ta.focus(); ta.select(); const ok=document.execCommand&&document.execCommand('copy'); toast(ok?'コピーしました':'コピー失敗'); window.getSelection().removeAllRanges(); }
}
async function pasteIn(target='input'){
  try{
    const t = await navigator.clipboard.readText();
    if(!t){ toast('クリップボードが空です', true); return; }
    (target==='input'? el.input: el.output).value = t;
    toast('貼り付けました'); syncOutputHeight();
  }catch(e){ toast('クリップボード読み取りが許可されていません', true); }
}
function handleFiles(files){
  if(!files||!files.length) return;
  const f=files[0], r=new FileReader();
  r.onload=e=>{ const b64=(String(e.target.result).split(',')[1]||''); el.output.value=b64; toast(f.name+' をBase64化しました'); };
  r.readAsDataURL(f);
}
function saveFile(){
  const b64=el.input?.value.trim(); if(!b64){ alert('Base64を入力してください'); return;}
  const name=(el.filename?.value.trim()||'download'); const ext=el.filetype?.value||'bin';
  const mime=({
    pdf:'application/pdf',
    docx:'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    xlsx:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    pptx:'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    png:'image/png', jpg:'image/jpeg', mp4:'video/mp4',
    exe:'application/vnd.microsoft.portable-executable',
    bin:'application/octet-stream'
  })[ext]||'application/octet-stream';
  try{
    const clean=normalizeB64(b64), bin=atob(clean); const arr=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i);
    const blob=new Blob([arr],{type:mime}); const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=`${name}.${ext}`; document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url),2000);
  }catch(e){ alert('保存に失敗: '+e.message); }
}

/* ===== Events ===== */
on(el.mEnc,'click',()=>setMode('ENC'));
on(el.mDec,'click',()=>setMode('DEC'));
on(el.mFile,'click',()=>setMode('FILE'));
on(el.mB2F,'click',()=>setMode('B2F'));
on(el.mCamB64,'click',()=>setMode('CAM_B64'));
on(el.mCamTxt,'click',()=>setMode('CAM_TXT'));
on(el.mCamB64M,'click',()=>setMode('CAM_B64_MULTI'));
on(el.mCamTxtM,'click',()=>setMode('CAM_TXT_MULTI'));

on(el.btnConv,'click',convert);
on(el.btnConvQR,'click',convertAndShow);

on(el.input,'keydown',e=>{
  if((e.ctrlKey||e.metaKey)&&e.key==='Enter' && (mode==='ENC'||mode==='DEC')){ e.preventDefault(); convert(); }
  if(e.shiftKey && e.key==='Enter' && (mode==='ENC'||mode==='FILE')){ e.preventDefault(); convertAndShow(); }
});
on(document,'keydown',e=>{
  if(e.shiftKey && e.key==='Enter' && (mode==='ENC'||mode==='FILE')){ e.preventDefault(); convertAndShow(); }
});

on(el.btnClear,'click',()=>{ el.input.value=''; syncOutputHeight(); el.input.focus(); });
on(el.btnCopy,'click',copyOut);
on(el.btnQR,'click',()=>{ if(buildSequence()){ pause(); renderQR(); } });

on(el.fps,'input',()=> setFps(el.fps.value));
on(el.fpsNum,'input',()=> setFps(el.fpsNum.value));
on(el.fpsNum,'change',()=> setFps(el.fpsNum.value));
on(el.scrub,'input',()=>{ idx=parseInt(el.scrub.value||'0',10)||0; renderQR(); updateTimeLabels(); updateFrameInd(); });
on(el.btnPrev,'click',prev);
on(el.btnNext,'click',next);
on(el.btnPlay,'click',()=> playing?pause():play());

on(el.fileBtn,'click',()=>el.fileInput?.click());
on(el.fileInput,'change',()=>handleFiles(el.fileInput?.files));
on(el.drop,'dragover',e=>{ e.preventDefault(); });
on(el.drop,'drop',e=>{ e.preventDefault(); handleFiles(e.dataTransfer?.files); });

on(el.btnSave,'click',saveFile);
on(el.btnPaste,'click',()=>pasteIn('input'));
on(el.btnPasteB2F,'click',()=>pasteIn('input'));
on(el.btnClearB2F,'click',()=>{ el.input.value=''; el.input.focus(); });

/* Camera */
on(el.btnScanStart,'click',startScan);
on(el.btnScanStop,'click',stopScan);

/* Resize / grid options */
['change','input'].forEach(ev=>{
  on(el.rows,ev,drawOverlayGrid);
  on(el.cols,ev,drawOverlayGrid);
  on(el.roiMargin,ev,drawOverlayGrid);
});
on(el.cam,'loadedmetadata',()=>{ ensureOverlaySize(true); drawOverlayGrid(); });
on(window,'resize',()=>{ ensureOverlaySize(true); drawOverlayGrid(); syncOutputHeight(); adjustFileDropHeight(); });

/* Ripple */
document.addEventListener('click',(e)=>{
  const b=e.target.closest('button.ripple'); if(!b) return;
  const r=b.getBoundingClientRect();
  const x=((e.clientX-r.left)/r.width)*100, y=((e.clientY-r.top)/r.height)*100;
  b.style.setProperty('--ripple-x',x+'%'); b.style.setProperty('--ripple-y',y+'%');
  b.classList.remove('rippling'); void b.offsetWidth; b.classList.add('rippling');
  setTimeout(()=>b.classList.remove('rippling'),600);
});

/* Help */
const help={modal:$('help-modal'), btnOpen:$('btn-help'), btnClose:$('btn-help-close'), btnPrint:$('btn-help-print'),
  qrBox:$('help-qr'), version:$('about-version'), opened:false};
function openHelp(){ if(!help.modal) return;
  help.modal.classList.add('show'); help.modal.setAttribute('aria-hidden','false'); help.opened=true;
  if(help.version) help.version.textContent = `${APP_VERSION}（ビルド: ${APP_BUILD}）`;
}
function closeHelp(){ if(!help.modal) return; help.modal.classList.remove('show'); help.modal.setAttribute('aria-hidden','true'); help.opened=false; }
on(help.btnOpen,'click',openHelp);
on(help.btnClose,'click',closeHelp);
on(help.modal,'click',(e)=>{ if(e.target===help.modal) closeHelp(); });
on(document,'keydown',(e)=>{ if(e.key==='Escape'&&help.opened) closeHelp(); });
on(help.btnPrint,'click',()=>window.print());

/* Init */
setMode('ENC');
setFps(el.fps.value);
syncOutputHeight();

}); // DOMContentLoaded
</script>
</body>
</html>

